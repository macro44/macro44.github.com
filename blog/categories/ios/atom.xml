<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2015-12-11T12:20:04+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    <email><![CDATA[macro_zj@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Runloop的常见使用]]></title>
    <link href="http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong/"/>
    <updated>2015-12-09T16:32:18+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong</id>
    <content type="html"><![CDATA[<blockquote><p>在之前就做过倒计时的功能，最近封装了一个倒计时的控件，之前一直是用第三方库，没有仔细的去了解原理，最近刚好有时间，就研究了一下NSTimer这个类，在研究的过程中，就发现了，NSTimer需与NSRunLoop结合起来玩的才溜，于是就有了这一篇，在我之前项目中遇到的runloop使用以及结合相关资料的总结;这是第一部分，接下来会在另一篇博客中讲解runloop的原理，以及我对runloop的理解。</p></blockquote>

<!--more-->


<h3>用于“暂停”程序</h3>

<pre><code>- (void)start{
    NSLog(@"start new thread …");
    [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil];
    while (!end) {
        NSLog(@"runloop…");
    ① [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
        NSLog(@"runloop end.");
    }
    NSLog(@"ok.");

}

- (void)runOnNewThread{
    NSLog(@"run for new thread …");
    sleep(1);
    ② [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO];
    NSLog(@"end.");
}

- (void)setEnd{
    end=YES;
}
</code></pre>

<p>调用start方法，输出结果为</p>

<pre><code>2015-12-09 15:42:14.828 Test1[1648:451473] start new thread …
2015-12-09 15:42:14.829 Test1[1648:451473] runloop…
2015-12-09 15:42:14.829 Test1[1648:451585] run for new thread …
2015-12-09 15:42:15.829 Test1[1648:451585] end.
2015-12-09 15:43:00.010 Test1[1648:451473] runloop end.
2015-12-09 15:43:00.010 Test1[1648:451473] ok.
</code></pre>

<p>解释一下为什么要调用②，因为在调用此方法会向主线程发送消息，唤醒runloop，从而及时响应任务；</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码中不难看出，函数的调用顺序，runloop之前的部分 －> newThread部分 －> runloop之后的部分;这样就相当于帮我们形成了一个线程阻塞，但是while循环不受影响，<br/>
<font color=blue size=3>[常见应用场景:]</font>newThread处理网络请求，runloop前后控制是否显示进度菊花</p>

<p></br></p>

<h3>在使用NSTimer的同时使用NSRunloop</h3>

<p>①当使用<a href=#2015120901> scheduledTimerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120902> scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </a>创建NSTimer实例的时候，使用的mode为NSDefaultRunLoopMode</p>

<p>②当使用<a href=#2015120903> timerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120904> timerWithTimeInterval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>③当使用<a href=#2015120906> initWithFireDate:interval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>在某些复杂页面，可能出现NSTimer计时延误的情况，有以下两条思路解决这个问题，1、在子线程中进行NSTimer的操作；2、仍然在主线程中进行NSTimer操作，但是将NSTimer加入到main runloop的特定的mode中；<br/>
</br>
方法1：</p>

<pre><code> if (self.timer) {
     [self.timer invalidate];
     self.timer = nil;
 }
 self.timer = [NSTimer timerWithTimeInterval:0.01 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
</code></pre>

<p>方法2:</p>

<pre><code>创建线程
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
 [thread start];

 //在子线程中做的事情 
-  (void)newThread
 {
     @autoreleasepool
    {
         [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] run];
     }
}
</code></pre>

<p>方法3:</p>

<pre><code>//声明全局变量
 dispatch_source_t _timers;


 uint64_t interval = 0.01 * NSEC_PER_SEC;
 dispatch_queue_t queue = dispatch_queue_create("my queue", 0);
 _timers = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
 dispatch_source_set_timer(_timers, dispatch_time(DISPATCH_TIME_NOW, 0), interval, 0);
  __weak ViewController *blockSelf = self;
 dispatch_source_set_event_handler(_timers, ^()
 {
     NSLog(@"Timer %@", [NSThread currentThread]);
     [blockSelf addTime];
 });
 dispatch_resume(_timers);

- (void)addTime{
    //然后在主线程中修改UI界面：
     dispatch_async(dispatch_get_main_queue(), ^{
             self.label.text = [NSString stringWithFormat:@"%.2f", self.timeCount/100];
     });
 }
</code></pre>

<p><b id=2015120901>+ scheduledTimerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                             invocation:(NSInvocation *)invocation
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120902>+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                                 target:(id)target
                               selector:(SEL)aSelector
                               userInfo:(id)userInfo
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120903>+ timerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120904>+ timerWithTimeInterval:target:selector:userInfo:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                        target:(id)target
                      selector:(SEL)aSelector
                      userInfo:(id)userInfo
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120905>-  addTimer:forMode:</b></p>

<pre><code>- (void)addTimer:(NSTimer *)aTimer
     forMode:(NSString *)mode
</code></pre>

<p><b id=2015120906>- initWithFireDate:interval:target:selector:userInfo:repeats:</b></p>

<pre><code>- (instancetype)initWithFireDate:(NSDate *)date
                    interval:(NSTimeInterval)seconds
                      target:(id)target
                    selector:(SEL)aSelector
                    userInfo:(id)userInfo
                     repeats:(BOOL)repeats
</code></pre>

<p>  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">NSTimer官方参考文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的@dynamic]]></title>
    <link href="http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic/"/>
    <updated>2015-12-07T16:58:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic</id>
    <content type="html"><![CDATA[<blockquote><p>在分析一份代码的时候，遇到了@dynamic，以前也遇到过，但是没有系统的总结一下，刚好有空，系统总结一下，为以后的使用做好准备；</p></blockquote>

<p>一、@dynamic与@synthesize的区别</p>

<ol>
<li>@property有两个对应的词，一个是@synthesize,另一个是@dynamic,当两个都没写的时候，系统会默认为写了@property的属性添加@synthesize var=_var;</li>
<li>@synthesize的语义为如果你没有重写getter或setter方法，系统会自动帮忙生成getter和setter方法，@dynamic的语义为getter和setter方法由用户自己实现，不自动生成；</li>
</ol>


<!--more-->


<p>二、@dynamic的读取<br/>
View.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface View : UIView
{
    NSString * _name;
}

@property (nonatomic,copy) NSString *name;

@end
</code></pre>

<p>View.m</p>

<pre><code>#import "View.h"

@implementation View

@dynamic name;

- (void)setName:(NSString *)name{
   _name = name;
}

- (NSString*)name{
   return _name;
}

@end
</code></pre>

<p>如果没有写setter和getter两个方法，调用的时候，[[View alloc] init].name会报错，但是将@dynamic换成@synthesize的话没有getter和setter也不会有问题；</p>

<p>三、@dynamic的使用</p>

<ol>
<li>用于NSManagedObject中，告诉编译器不要处理属性的getter和setter方法，由CoreData框架来生成getter和setter方法</li>
<li><p>用于分类中,具体使用需要结合到runtime，让分类可以存在属性变量<br/>
例子如下：<br/>
NSObject + AAA.h</p>

<pre><code>  #import &lt;Foundation/Foundation.h&gt;

  @interface NSObject (AAA)
  @property (nonatomic,copy) NSString *aaa;

  @end
</code></pre></li>
</ol>


<p>NSObjct + AAA.m</p>

<pre><code>    #import "NSObject+AAA.h"
    #import &lt;objc/runtime.h&gt;

    static const void *kAAAIdentifier = (void*)@"kAAAIdentifier";

    @implementation NSObject (AAA)

    @dynamic aaa;

    - (void)setAaa:(NSString *)aaa{
            objc_setAssociatedObject(self, kAAAIdentifier, aaa, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }

    - (NSString*)aaa{
        return  objc_getAssociatedObject(self, kAAAIdentifier);
    }

    @end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath学习总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/"/>
    <updated>2015-12-03T17:00:10+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css"></p>

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>


<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>




<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>


<div id="category"></div>


<blockquote><p>UIBezierPath对象是CGPathRef数据类型的封装，每一个连接的直线或者去险段的集合称为subpath，一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths，使用UIBezierPath类可以创建机遇矢量的路径，使用此类可以定义简单的形状，如椭圆或者矩形，也可以定义稍微复杂的形状，如多个直线和曲线组成的形状;</p></blockquote>

<!--more-->


<h3>1.UIBezierPath的创建</h3>

<h4>1.1. + bezierPath</h4>

<pre><code>+ (instancetype)bezierPath
返回一个UIBezierPath实例;
</code></pre>

<h4>1.2. + bezierPathWithRect:</h4>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect
传入一个CGRect，构建一个矩形
</code></pre>

<h4>1.3. + bezierPathWithOvalInRect:</h4>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect
传入一个CGRect，构建一个内切椭圆
</code></pre>

<h4>1.4. + bezierPathWithRoundedRect:cornerRadius:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                         cornerRadius:(CGFloat)cornerRadius
创建一个圆角矩形，其中rect为矩形的rect，cornerRadius为圆角率
</code></pre>

<h4>1.5. + bezierPathWithRoundedRect:byRoundingCorners:cornerRadii:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                    byRoundingCorners:(UIRectCorner)corners
                          cornerRadii:(CGSize)cornerRadii
构建一个可指定圆角的矩形,其中rect为矩形的rect，corners为需要圆角的角,cornerRadii为圆角
率(sized的    组成最大不能超过宽高的一半)
</code></pre>

<h4>1.6. + bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center
                             radius:(CGFloat)radius
                         startAngle:(CGFloat)startAngle
                           endAngle:(CGFloat)endAngle
                          clockwise:(BOOL)clockwise
创建一段圆弧,center为圆弧的圆心，radius为半径,startAngle为开始弧度，endAngle为结束弧
度,clockwise为方向  (默认YES为顺时针方向，No为逆时针方向)，具体的开始点与结束点看下方参
考图  
</code></pre>

<p>其中正右顶点为起始点也为结束点,顺时针依次增加;  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120401.png" alt="参考图" /><br/>
<font color=red size=3>[注意]:</font>之所以强调顺时针方向与逆时针防线的原因是，当起始弧度与结束弧度相同的时候，不同的方向画线会得到不同的结果，如0和π/2，顺时针会得到右下部的1/4部分，但逆时针会得到上面的3/4部分;</p>

<h4>1.7. + bezierPathWithCGPath:</h4>

<pre><code>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath
用CGPath创建一个UIBezierPath
</code></pre>

<h4>1.8. - bezierPathByReversingPath</h4>

<pre><code>- (UIBezierPath *)bezierPathByReversingPath
创建一个与原bezierPath路径相同，方向相反的bezierPath对象
</code></pre>

<h3>2. 构建路径</h3>

<h4>2.1. - moveToPoint:</h4>

<pre><code>- (void)moveToPoint:(CGPoint)point
移动起始点到指定位置
</code></pre>

<h4>2.2. - addLineToPoint:</h4>

<pre><code>- (void)addLineToPoint:(CGPoint)point
从起始点增加一条线到指定的point，并在下一次改变时把point当起始点
</code></pre>

<h4>2.3. - addArcWithCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>- (void)addArcWithCenter:(CGPoint)center
              radius:(CGFloat)radius
          startAngle:(CGFloat)startAngle
            endAngle:(CGFloat)endAngle
           clockwise:(BOOL)clockwise
增加一段圆弧，center为圆弧的圆心,radius为圆弧的半径,startAngle为起始圆弧度数,endAngle
为终止圆弧度数,clockwise为是否是顺时钟，与
（+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:）
的演示图中度数的起始点和终止点相同
</code></pre>

<h4>2.4. - addQuadCurveToPoint:controlPoint:</h4>

<pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint
           controlPoint:(CGPoint)controlPoint
新增一段二阶贝塞尔曲线，其中endPoint为结束点，controlPoint为控制点
</code></pre>

<p>二阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120402.png" alt="演示图2" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.5. - addCurveToPoint:controlPoint1:controlPoint2:</h4>

<pre><code>- (void)addCurveToPoint:(CGPoint)endPoint
      controlPoint1:(CGPoint)controlPoint1
      controlPoint2:(CGPoint)controlPoint2
新增一段三阶贝塞尔曲线，其中endPoint结束点，controlPoint1为控制点1,controlPoint2为控制点2
</code></pre>

<p> 三阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120403.png" alt="演示图3" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.6. - closePath</h4>

<pre><code>- (void)closePath
用线段连接最后一个点与最初起始点，使成为一个封闭的形状
</code></pre>

<h4>2.7. - removeAllPoints</h4>

<pre><code>- (void)removeAllPoints
移除所有的点，同时也移除所有的线
</code></pre>

<h4>2.8. - appendPath:</h4>

<pre><code>- (void)appendPath:(UIBezierPath *)bezierPath
将一段路径连接到另外一段路径后面
</code></pre>

<h4>2.9. CGPath <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGPathRef CGPath
主要作用就是获取UIBezierPath的CGPathRef实例，可以用于初始化或者添加到另一个path中。
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
+ bezierPathWithCGPath:  <br/>
- appendPath:</p>

<h4>2.10. cuttrentPoint  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic, readonly) CGPoint currentPoint
主要用于获取当前的坐标点，如果当前路径为空，则当前点的值为坐标原点
</code></pre>

<h3>3. 绘图属性</h3>

<h4>3.1. lineWidth  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGFloat lineWidth
绘图线的宽度,默认为1.0
</code></pre>

<h4>3.2. lineCapStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineCap lineCapStyle
设置起点和终点的样式

enum CGLineCap{
    kCGLineCapButt,
    kCGLineCapRound,
    kCGLineCapSquare 
};
typedef enum CGLineCap CGLineCap;
</code></pre>

<h4>3.3. lineJoinStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineJoin  lineJoinStyle
设置线段连接点的样式

enum CGLineJoin{
    kCGLineJoinMiter,  
    kCGLineJoinRound,
    kCGLineJoinBevel 
}; 
typedef enum CGLineJoin CGLineCap;
</code></pre>

<h4>3.4. usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property (nonatomic) BOOL usesEvenOddFillRule
判断是否使用奇-偶规则绘图, 默认为NO,即采用非零环绕规则绘图
</code></pre>

<p><font color=orange>［名词解释］:</font> 奇－偶规则: 从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。<br/>
非零环绕规则: 首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。左边为奇－偶规则的渲染图，右边为非零环绕规则的渲染图；
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120404.png" alt="演示图4" /></p>

<h4>3.5. - setLineDash:count:phase:</h4>

<pre><code>- (void)setLineDash:(const CGFloat *)pattern
          count:(NSInteger)count
          phase:(CGFloat)phase
画一条虚线,其中pattern为一个C风格的数组，包含段点的长度，count为pattern的数量，phase为
间隔的宽度

例子:    
UIBezierPath *path = [UIBezierPath bezierPath];

path.lineWidth = 5;
path.lineJoinStyle = kCGLineJoinRound;
path.lineCapStyle = kCGLineCapRound;
[path moveToPoint:CGPointMake(100, 100)];
[path addLineToPoint:CGPointMake(200, 100)];

CGFloat a[] = {10};
[path setLineDash:a count:1 phase:5];
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015120406.png" alt="演示图5" /></p>

<h4>3.6 - getLineDash:count:phase:</h4>

<pre><code>- (void)getLineDash:(CGFloat *)pattern
          count:(NSInteger *)count
          phase:(CGFloat *)phase
获取虚线中的属性，pattern为C风格的数组，包含段点的信息,count包含pattern的数量，phase为
间隔的宽度，必须要确保pattern数组足够大，当不知道pattern的长度的时候，可以调用两次该方法，
第一次pattern传NULL，然后根据返回的count值创建数组，再次调用；
</code></pre>

<h4>3.7. - containsPoint:</h4>

<pre><code>- (BOOL)containsPoint:(CGPoint)point
判断点是否在某个封闭区域内，必须是封闭区域，可以调用－ closePath；
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
- closePath:  <br/>
usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></p>

<h3>4. 绘图</h3>

<h4>4.1. - fillWithBlendMode:alpha:</h4>

<pre><code>- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha
填充一个path，blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.2. - strokeWithBlendMode:alpha:</h4>

<pre><code>- (void)strokeWithBlendMode:(CGBlendMode)blendMode
                  alpha:(CGFloat)alpha
以某种方式渲染边界线,blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.3. -fill</h4>

<pre><code>- (void)fill
填充某个路径
</code></pre>

<h4>4.4 - stroke</h4>

<pre><code>- (void)stroke
绘制路径
</code></pre>

<h3>5.动画</h3>

<h4>5.1 - applyTransform:</h4>

<pre><code>- (void)applyTransform:(CGAffineTransform)transform
对路径实现变换，transform变换
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS链式开发(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-%5B%3F%5D/"/>
    <updated>2015-12-02T16:29:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-[?]</id>
    <content type="html"><![CDATA[<blockquote><p>烦不烦？当你需要调用一组动画的时候，需要一个个函数组件的去调用，其实你可以运用你之前学过的block，来实现如一系列的连贯触发行为；</p></blockquote>

<h3>什么是链式开发</h3>

<p>简单的说就是通过“.”操作符调用一系列的操作；</p>

<!--more-->


<h3>链式开发在OC中操作的原理</h3>

<p>原理：结合类属性的getter属性可以通过.调用的特性，我们可以在每一个需要触发的链式环节，定义一个类属性，然后再类属性中返回类的实例，这样，就可以一系列的执行下去；</p>

<p>如:假设有类ChainInvoking;以及属性<code>@property （nonatomic, copy）ChainInvoking* invoking;</code>
则</p>

<pre><code>－ （ChainInvoking* ）invoking{
    /**
        我们想做的事情;
    **/
    return self;
}
</code></pre>

<p>那么此时，self.invoking与self在意义上其实是相等的，不过在self.invoking已经帮我们做了我们想做的事情，一次类推，如果我们有一系列的动作，那么<code>self.invoking1.invoking2...</code>也是可行的，这样就实现了我们的链式调用</p>

<h3>为什么用block而不是直接用类属性</h3>

<ol>
<li>类属性不能传入参数，那么相应的一些功能的时候局限性更大</li>
<li>在最后一个调用的时候，会报警告"Property access result unused-getter should not be used for side effects",意思大概就是获取的getter值，没有实际用途;<br/>
<strong>综上</strong>,最好的办法是使用block 类属性，下面会给大家展示一个例子;</li>
</ol>


<h3>链式操作的实现</h3>

<p>用一个例子说明： <br/>
<strong>ChainedInvoking.h</strong></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface ChainedInvoking : NSObject

@property (nonatomic, copy) ChainedInvoking* (^eat1)();
@property (nonatomic, copy) ChainedInvoking* (^eat)(NSString* );
@property (nonatomic, copy) ChainedInvoking* (^run)();
@property (nonatomic, copy) ChainedInvoking* (^learn)();

@property (nonatomic, copy) ChainedInvoking* play;
@property (nonatomic, copy) ChainedInvoking* sing;
@end
</code></pre>

<p><strong>ChainedInvoking.m</strong></p>

<pre><code>#import "ChainedInvoking.h"

@implementation ChainedInvoking

- (ChainedInvoking* (^)())eat1{  
   return ^{
        NSLog(@"吃饭");
        return self;
  };
}

- (ChainedInvoking* (^)())learn{
    return ^{
     NSLog(@"学习");
        return self;
    };
}   

- (ChainedInvoking* (^)())run{
    return ^{
        NSLog(@"跑步");
        return self;
    };
}

- (ChainedInvoking* (^)(NSString* food))eat{
    return ^(NSString* food){
        NSLog(@"吃---%@",food);
        return self;
    };
}

- (ChainedInvoking*)play{
    NSLog(@"玩耍!");
    return self;
}

- (ChainedInvoking*)sing{
    NSLog(@"唱歌!");
    return self;
}       

@end
</code></pre>

<p><strong>调用:   </strong></p>

<pre><code>ChainedInvoking* invoking = [[ChainedInvoking alloc] init];
invoking.eat1().run().learn().eat(@"辣子鸡饭"); ①
invoking.play.sing.eat(@"红烧牛肉面"); ②
</code></pre>

<p><strong>结果</strong><br/>
①</p>

<pre><code>吃饭
跑步
学习
吃-－－辣子鸡饭
</code></pre>

<p>②</p>

<pre><code>玩耍
唱歌
吃红烧牛肉面
</code></pre>

<h3>参考文档</h3>

<p><a href="http://www.cocoachina.com/ios/20151123/14317.html">使用OC链式调用方式简化SpriteKit的动画调用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用跳转设置]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi/"/>
    <updated>2015-12-02T14:50:56+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi</id>
    <content type="html"><![CDATA[<blockquote><p>经常会在应用中应用中遇到这样的问题，在app内部运行到某个场景的时候，需要打开系统的某项设置，但由于用户的不小心操作，或者当时的一些小想法而在系统弹框的时候选择了拒绝，之后就不能收到某项服务或者在app运行的环节中造成断片，这个时候我们就需要提醒用户手动去去打开系统设置，然后打开相应的服务，这给用户的体验是不好的，最好的用户体验是，如果用户拒绝了某项服务，但当他进入这个应用场景的时候，弹框提示用户的同时，还应该跳转到响应的系统设置页面，进行设置。</p></blockquote>

<!--more-->


<p></br></p>

<h3>跳转本App设置界面以及相应的系统版本</h3>

<p>需要请求一下位置权限或者通知权限，才可以跳进自己的app设置里面，如果没有任何权限请求，就只能跳到系统的设置界面<br/>
<strong>iOS8及以上</strong></p>

<pre><code>        NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
        if([[UIApplication sharedApplication] canOpenURL:url]) {
            NSURL*url =[NSURL URLWithString:UIApplicationOpenSettingsURLString];
            [[UIApplication sharedApplication] openURL:url];
        }
</code></pre>

<p><strong>iOS8以下</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开应用的相册、推送、位置等等信息的时候会跳转到相应的页面</p>

<p></br></p>

<h3>跳转到系统设置</h3>

<p><strong>通用模版</strong></p>

<ol>
<li><p>设置Url Schemes(Target > info > URL Type)<br/>
     <img src="http://7xopon.com1.z0.glb.clouddn.com/8.png" alt="urlSchemes设置" /></p></li>
<li><p>项目相应位置相应的代码<br/>
＃define kCommonMacro  系统设置root</p>

<pre><code>   NSURL *url = [NSURL URLWithString:@"kCommonMacro"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }

  例子:
  **WIFI**
   NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }
</code></pre></li>
</ol>


<p><strong>常用的系统设置prefs</strong></p>

<ul>
<li><p>Notification <pre/>prefs:root=NOTIFICATIONS_ID</p></li>
<li><p>About <pre/>prefs:root=General&amp;path=About</p></li>
<li><p>Accessibility <pre/>prefs:root=General&amp;path=ACCESSIBILITY</p></li>
<li><p>AirplaneModeOn <pre/>prefs:root=AIRPLANE_MODE</p></li>
<li><p>Auto-Lock <pre/>prefs:root=General&amp;path=AUTOLOCK</p></li>
<li><p>Brightness <pre/>prefs:root=Brightness</p></li>
<li><p>Bluetooth <pre/>prefs:root=General&amp;path=Bluetooth</p></li>
<li><p>Date&amp; Time <pre/>prefs:root=General&amp;path=DATE_AND_TIME</p></li>
<li><p>FaceTime <pre/>prefs:root=FACETIME</p></li>
<li><p>General <pre/>prefs:root=General</p></li>
<li><p>Keyboard <pre/>prefs:root=General&amp;path=Keyboard</p></li>
<li><p>iCloud <pre/>prefs:root=CASTLE  iCloud</p></li>
<li><p>Storage &amp; Backup <pre/>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</p></li>
<li><p>International <pre/>prefs:root=General&amp;path=INTERNATIONAL</p></li>
<li><p>Location Services <pre/>prefs:root=LOCATION_SERVICES</p></li>
<li><p>Music <pre/>prefs:root=MUSIC</p></li>
<li><p>Music Equalizer <pre/>prefs:root=MUSIC&amp;path=EQ</p></li>
<li><p>Music VolumeLimit <pre/>prefs:root=MUSIC&amp;path=VolumeLimit</p></li>
<li><p>Network <pre/>prefs:root=General&amp;path=Network</p></li>
<li><p>Nike + iPod <pre/>prefs:root=NIKE_PLUS_IPOD</p></li>
<li><p>Notes <pre/>prefs:root=NOTES</p></li>
<li><p>Phone <pre/>prefs:root=Phone</p></li>
<li><p>Photos <pre/>prefs:root=Photos</p></li>
<li><p>Profile <pre/>prefs:root=General&amp;path=ManagedConfigurationList</p></li>
<li><p>Reset <pre/>prefs:root=General&amp;path=Reset</p></li>
<li><p>Safari <pre/>prefs:root=Safari</p></li>
<li><p>Siri <pre/>prefs:root=General&amp;path=Assistant</p></li>
<li><p>Sounds <pre/>prefs:root=Sounds</p></li>
<li><p>SoftwareUpdate <pre/>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</p></li>
<li><p>Store <pre/>prefs:root=STORE</p></li>
<li><p>Twitter <pre/>prefs:root=TWITTER</p></li>
<li><p>Usage <pre/>prefs:root=General&amp;path=USAGE</p></li>
<li><p>VPN <pre/>prefs:root=General&amp;path=Network/VPN</p></li>
<li><p>Wallpaper <pre/>prefs:root=Wallpaper</p></li>
<li><p>Wi-Fi <pre/>prefs:root=WIFI</p></li>
<li><p>Setting  <pre/>prefs:root=INTERNET_TETHERING</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
