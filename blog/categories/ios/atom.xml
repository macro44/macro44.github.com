<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2016-02-25T17:32:30+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    <email><![CDATA[macro_zj@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[代理、通知、block的比较]]></title>
    <link href="http://macro44.github.io/blog/2016/02/25/dai-li-,-tong-zhi-,-blockde-bi-jiao/"/>
    <updated>2016-02-25T12:39:16+08:00</updated>
    <id>http://macro44.github.io/blog/2016/02/25/dai-li-,-tong-zhi-,-blockde-bi-jiao</id>
    <content type="html"><![CDATA[<blockquote><p>代理、通知、block三者在iOS编程中是较为常见的回调模式，三者的用法也有诸多类似之处，但是在具体场景中的选择对于初学者或者研究不够深入的同学来说是比较“随性”的，本文就总结归纳一下三者的用法，以及三者的区别。</p></blockquote>

<!--more-->


<h3>代理模式</h3>

<p>代理模式包含三个方面：1、委托方；2、代理方；3、两者之间的协议；三者之间的关系如下图
<img src="http://7xopon.com1.z0.glb.clouddn.com/2016022501.png" alt="代理模式关系图" /><br/>
一般情况下，我们把协议与委托方放在一块。可以这样去理解，有一些需求、或者有一些数据在委托方没有办法得到，只能通过第二方提供，当然也可以独立。</p>

<p>具体代码：数据传递、事件处理</p>

<pre><code>//协议部分
@protocol CallBackDelegate &lt;NSObject&gt;

- (void)showArrayWithDelegate:(NSArray*)dataArray;

@end

//委托方
@interface CallBackProtocol : NSObject

@property (nonatomic,weak) id&lt;CallBackDelegate&gt; delegate;

@end

//代理方
//1、实现代理的指向，即将CallBackDelegate指向代理方，一般形式
//self.delegate = 委托方.delegate

//2、实现具体的代理方法
- (void)showArrayWithDelegate:(NSArray*)dataArray{
//代理的事情
    _dataArray = dataArray;
}
</code></pre>

<h3>通知模式</h3>

<p>通知是一种一对多的数据传递、或者事件响应模式，主要需要设置两个方面，1、观察者；2、发送通知方；通过推送中心进行消息转发
<img src="http://7xopon.com1.z0.glb.clouddn.com/2016022502.png" alt="通知模式" /><br/>
实现的步骤：1、注册观察者 2、接收通知 3、移除观察者</p>

<p>具体代码：数据传递、事件处理</p>

<pre><code>//注册观察者
- (void)viewWillAppear:(BOOL)animated{
[super viewWillAppear:animated];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(resiveNotification:) name:@"resiviXXXNotification" object:nil];
}

//发送消息
 [[NSNotificationCenter defaultCenter] postNotificationName:@"resiviXXXNotification" object:nil];

 //移除观察者
 - (void)viewWillDisappear:(BOOL)animated{
[[NSNotificationCenter defaultCenter] removeObserver:self name:@"resiviXXXNotification" object:nil];
}
</code></pre>

<h3>block</h3>

<p>相对于delegate或者通知，block相对较为方便。且易读性更强。block可以看成是一个内部函数整体;<br/>
具体代码：</p>

<pre><code>//声明Block
typedef void(^CallBackBlock)(NSInteger);

//内部方法
- (void)sendData:(CallBackBlock)block{
    block(3);
}

//调用函数
[self sendData:^(NSInteger i){
    _number = i;
}];
</code></pre>

<p>需要特别注意的点:block的使用需要注意循环引用的问题<br/>
在ARC下：</p>

<pre><code>__weak typeof(self) weakSelf = self;
[self sendData:(^NSInteger i){
    [weakSelf  doSomething];
}];  
</code></pre>

<p>在MRC下:</p>

<pre><code>__block typeof(self) weakSelf = self;
[self sendData:(^NSInteger i){
    [weakSelf doSomething];
}];
</code></pre>

<p><a href="http://fuckingblocksyntax.com/">block用法大全</a></p>

<h3>三者区别:</h3>

<p>1、通知是一种一对多的模式，当有很多的控制器需要知道一个事件，就用通知。但是有一个弊端，当接收的对象多了的话，就有可能存在不想接收通知的对象接收到通知，且需要注意，一定要在dealloc中移除。
2、delegate与block都是一对一的模式，两者的比较：a、block相对要方便，且易读性高；b、delegate运行的成本更低，当block出栈的时候需要由栈内存拷贝到堆内存，对象需要增加引用计数，使用完或者block置为nil才移除，delegate只保存一个对象的指针，没有额外的消耗；c、delegate更加适合过程信息的传输,比如想要知道表格是否滑动，滑到了那样的位置，是否结束滑动。而block更加注重结果</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(二)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er/"/>
    <updated>2015-12-14T18:11:05+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS可执行文件瘦身方法</font></div>


<blockquote><p>在第一部分中，我们已经介绍了如何获取可执行文件组成列表，以及如何查看静态链接库的占比的方法。这一部分我们将来仔细介绍可执行文件瘦身的具体方法；</p></blockquote>

<p><a href="http://blog.cnbang.net/tech/2544/">转载于bang&rsquo;s blog</a>
</br></p>

<!--more-->


<h3>编译选项</h3>

<ol>
<li>编译器优化级别
Build Settings->Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</li>
<li><p>去除符号信息
Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，详细信息见<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-97021-TPXREF121">官方文档</a>。</p>

<p>  这些选项目前都是XCode里release的默认选项，但旧版XCode生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/legacy/library/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.pdf">CodeFootprint.pdf</a></p></li>
</ol>


<h3>第三方库统计</h3>

<p>通过<a href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/">(一)</a>中对可执行文件的分析可以知道第三方库的占比，从而判断是否值得去找可执行方案去替换掉这个第三方库，转载作者写了一个node.js脚本，可以通过linkmap去统计每个.o目标文件占用的体积和每个.a静态库占用的体积.具体在<a href="https://gist.github.com/bang590/8f3e9704f1c2661836cd">详见这里</a></p>

<h3>ARC ->MRC</h3>

<p>具体没看懂，知道结论是可减少资源包的8%左右，有兴趣的可查看<a href="http://blog.cnbang.net/tech/2544/">原文</a>,但是这样程序的维护成本就上升了，如果没有特殊情况，一般不建议使用.</p>

<h3>无用代码</h3>

<p>在项目里新建一个类，给它添加几个方法，但不要在任何地方import它，build完项目后观察linkmap，你会发现这个类还是被编译进可执行文件了。
按C++的经验，没有被使用到的类和方法编译器都会优化掉，不会编进最终的可执行文件，但object-c不一样，因为object-c的动态特性，它可以通过类和方法名反射获得这个类和方法进行调用，所以就算在代码里某个类没被使用到，编译器也没法保证这个类不会在运行时通过反射去调用，所以只要是在项目里的文件，无论是否又被使用到都会被编译进可执行文件。
对此我们可以通过脚本，遍历整个项目的文件，找出所有没有被引用的类文件和没有被调用的方法，在保证没有其他地方动态调用的情况下把它们去掉。如果整个项目历时很长，历时代码遗留较多，这个清理对可执行文件省出的空间还是挺可观的。</p>

<h3>类/方法名的长度</h3>

<p>观察linkmap可以发现每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来。
对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩js一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它class-dump出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行hack。不过这样做有个缺点，就是crash堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆->原名的转换，实现和使用成本有点高。
实际上这部分占用的长度比较小，中型项目也就几百K，对安全性要求高的情况可以试试。</p>

<h3>冗余字符串</h3>

<p>代码上定义的所有静态字符串都会记录在在可执行文件的__cstring段，如果项目里Log非常多，这个空间占用也是可观的，也有几百K的大小，可以考虑清理所有冗余的字符串。另外如果有特别长的字符串，建议抽离保存成静态文件，因为AppStore对可执行文件加密导致压缩率低，特别长的字符串抽离成静态资源文件后压缩率会比在可执行文件里高很多。</p>

<h3>列一个清单</h3>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015121403.png" alt="效果展示" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/"/>
    <updated>2015-12-14T16:17:28+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-[?]</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS App可执行文件的组成</font></div>


<blockquote><p>面试的时候遇到的面试题，如何给App瘦身，之前有看过类似的题目，讲的大概就是两个方面，一、给资源文件瘦身，2、能下载处理的尽量通过后续下载来处理。但没有实际操作过。所以总感觉回答的不是那么个味道。回来问同事以及查资料后果然，需要两个方面来瘦身：1、减少资源包的大小；2、减少可执行文件的大小。1在本博客后续博客中会提到如何瘦身，本文主要讲解可执行文件瘦身的一部分，App可执行文件的组成；</p></blockquote>

<!--more-->


<p><a href="http://blog.cnbang.net/tech/2296/">转载于bang&rsquo;s blog </a></p>

<h3>查看App可执行文件组成的方法</h3>

<ol>
<li><p>XCode开启编译选项Write Link Map File
Xcode -> Project -> Build Setting ->搜索map ->设置Write Link Map File为Yes<br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121401.png" alt="展示图片" /></p></li>
<li><p>编译后，通过路径查找找到图中txt文件对应的文件
具体路径: ~/Library/Developer/Xcode/DerivedData/XXX-xxxxxxxxxxxx/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/XXX-LinkMap-xxx.txt<br/>
（这个LinkMap展示了整个App中可执行文件的全貌，列出了编译后的每一个.o文件，包括.a文件里的，以及每一个目标文件的代码段，数据段存储详情等）</p></li>
<li><p>以我目前手上的项目为例，在linkMap中的文件列表，有部分删减，为了方便讲解
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121402.png" alt="展示图片" /></p>

<p>  第一部分(Object files部分)含义：<br/>
  前面中括号表示文件的编号，在后面的部分中会用到,后面表示可执行文件的位置</p>

<p>  第二部分(Sections部分)含义:<br/>
  Address表示偏移位置,Size表示大小,Segment表示段类型(<code>__TEXT</code>,保存程序代码段编译后的机器码，<code>__Data</code>),Section表示段名称(<code>__text</code>表示编译后的程序可执行语句，<code>__data</code>表示已初始化的全局变量和局部静态变量，<code>__bss</code>表示未初始化的全局变量和局部静态变量,<code>__csstring</code>表示代码里的字符串常量)</p>

<p>  可以发现每一行的数据都是紧跟在上一行数据后面， 即第二行到Address为第一行的Address加上第二行的Size组成</p>

<p>  第三部分(symbols部分)含义:
  Address 表示偏移位置,第二部分表示占用大小,第三部分表示所属文件序号，对应上述Object files列表，最后是文件名称</p></li>
<li><p>使用<br/>
 在了解了可执行文件的组成后，我们可以通过计算来获取某个静态库在项目中的占比，通过将.a静态库的.o加起来，就是这个静态库可执行部分占整个app空间的大小。（但是需要注意，此大小并不等于静态库的物理大小，此大小只是可执行文件的大小，要小于静态库的物理大小）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runloop的常见使用]]></title>
    <link href="http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong/"/>
    <updated>2015-12-09T16:32:18+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong</id>
    <content type="html"><![CDATA[<blockquote><p>在之前就做过倒计时的功能，最近封装了一个倒计时的控件，之前一直是用第三方库，没有仔细的去了解原理，最近刚好有时间，就研究了一下NSTimer这个类，在研究的过程中，就发现了，NSTimer需与NSRunLoop结合起来玩的才溜，于是就有了这一篇，在我之前项目中遇到的runloop使用以及结合相关资料的总结;这是第一部分，接下来会在另一篇博客中讲解runloop的原理，以及我对runloop的理解。</p></blockquote>

<!--more-->


<h3>用于“暂停”程序</h3>

<pre><code>- (void)start{
    NSLog(@"start new thread …");
    [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil];
    while (!end) {
        NSLog(@"runloop…");
    ① [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
        NSLog(@"runloop end.");
    }
    NSLog(@"ok.");

}

- (void)runOnNewThread{
    NSLog(@"run for new thread …");
    sleep(1);
    ② [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO];
    NSLog(@"end.");
}

- (void)setEnd{
    end=YES;
}
</code></pre>

<p>调用start方法，输出结果为</p>

<pre><code>2015-12-09 15:42:14.828 Test1[1648:451473] start new thread …
2015-12-09 15:42:14.829 Test1[1648:451473] runloop…
2015-12-09 15:42:14.829 Test1[1648:451585] run for new thread …
2015-12-09 15:42:15.829 Test1[1648:451585] end.
2015-12-09 15:43:00.010 Test1[1648:451473] runloop end.
2015-12-09 15:43:00.010 Test1[1648:451473] ok.
</code></pre>

<p>解释一下为什么要调用②，因为在调用此方法会向主线程发送消息，唤醒runloop，从而及时响应任务；</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码中不难看出，函数的调用顺序，runloop之前的部分 －> newThread部分 －> runloop之后的部分;这样就相当于帮我们形成了一个线程阻塞，但是while循环不受影响，<br/>
<font color=blue size=3>[常见应用场景:]</font>newThread处理网络请求，runloop前后控制是否显示进度菊花</p>

<p></br></p>

<h3>在使用NSTimer的同时使用NSRunloop</h3>

<p>①当使用<a href=#2015120901> scheduledTimerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120902> scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </a>创建NSTimer实例的时候，使用的mode为NSDefaultRunLoopMode</p>

<p>②当使用<a href=#2015120903> timerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120904> timerWithTimeInterval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>③当使用<a href=#2015120906> initWithFireDate:interval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>在某些复杂页面，可能出现NSTimer计时延误的情况，有以下两条思路解决这个问题，1、在子线程中进行NSTimer的操作；2、仍然在主线程中进行NSTimer操作，但是将NSTimer加入到main runloop的特定的mode中；<br/>
</br>
方法1：</p>

<pre><code> if (self.timer) {
     [self.timer invalidate];
     self.timer = nil;
 }
 self.timer = [NSTimer timerWithTimeInterval:0.01 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
</code></pre>

<p>方法2:</p>

<pre><code>创建线程
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
 [thread start];

 //在子线程中做的事情 
-  (void)newThread
 {
     @autoreleasepool
    {
         [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] run];
     }
}
</code></pre>

<p>方法3:</p>

<pre><code>//声明全局变量
 dispatch_source_t _timers;


 uint64_t interval = 0.01 * NSEC_PER_SEC;
 dispatch_queue_t queue = dispatch_queue_create("my queue", 0);
 _timers = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
 dispatch_source_set_timer(_timers, dispatch_time(DISPATCH_TIME_NOW, 0), interval, 0);
  __weak ViewController *blockSelf = self;
 dispatch_source_set_event_handler(_timers, ^()
 {
     NSLog(@"Timer %@", [NSThread currentThread]);
     [blockSelf addTime];
 });
 dispatch_resume(_timers);

- (void)addTime{
    //然后在主线程中修改UI界面：
     dispatch_async(dispatch_get_main_queue(), ^{
             self.label.text = [NSString stringWithFormat:@"%.2f", self.timeCount/100];
     });
 }
</code></pre>

<p><b id=2015120901>+ scheduledTimerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                             invocation:(NSInvocation *)invocation
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120902>+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                                 target:(id)target
                               selector:(SEL)aSelector
                               userInfo:(id)userInfo
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120903>+ timerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120904>+ timerWithTimeInterval:target:selector:userInfo:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                        target:(id)target
                      selector:(SEL)aSelector
                      userInfo:(id)userInfo
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120905>-  addTimer:forMode:</b></p>

<pre><code>- (void)addTimer:(NSTimer *)aTimer
     forMode:(NSString *)mode
</code></pre>

<p><b id=2015120906>- initWithFireDate:interval:target:selector:userInfo:repeats:</b></p>

<pre><code>- (instancetype)initWithFireDate:(NSDate *)date
                    interval:(NSTimeInterval)seconds
                      target:(id)target
                    selector:(SEL)aSelector
                    userInfo:(id)userInfo
                     repeats:(BOOL)repeats
</code></pre>

<p>  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">NSTimer官方参考文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的@dynamic]]></title>
    <link href="http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic/"/>
    <updated>2015-12-07T16:58:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic</id>
    <content type="html"><![CDATA[<blockquote><p>在分析一份代码的时候，遇到了@dynamic，以前也遇到过，但是没有系统的总结一下，刚好有空，系统总结一下，为以后的使用做好准备；</p></blockquote>

<p>一、@dynamic与@synthesize的区别</p>

<ol>
<li>@property有两个对应的词，一个是@synthesize,另一个是@dynamic,当两个都没写的时候，系统会默认为写了@property的属性添加@synthesize var=_var;</li>
<li>@synthesize的语义为如果你没有重写getter或setter方法，系统会自动帮忙生成getter和setter方法，@dynamic的语义为getter和setter方法由用户自己实现，不自动生成；</li>
</ol>


<!--more-->


<p>二、@dynamic的读取<br/>
View.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface View : UIView
{
    NSString * _name;
}

@property (nonatomic,copy) NSString *name;

@end
</code></pre>

<p>View.m</p>

<pre><code>#import "View.h"

@implementation View

@dynamic name;

- (void)setName:(NSString *)name{
   _name = name;
}

- (NSString*)name{
   return _name;
}

@end
</code></pre>

<p>如果没有写setter和getter两个方法，调用的时候，[[View alloc] init].name会报错，但是将@dynamic换成@synthesize的话没有getter和setter也不会有问题；</p>

<p>三、@dynamic的使用</p>

<ol>
<li>用于NSManagedObject中，告诉编译器不要处理属性的getter和setter方法，由CoreData框架来生成getter和setter方法</li>
<li><p>用于分类中,具体使用需要结合到runtime，让分类可以存在属性变量<br/>
例子如下：<br/>
NSObject + AAA.h</p>

<pre><code>  #import &lt;Foundation/Foundation.h&gt;

  @interface NSObject (AAA)
  @property (nonatomic,copy) NSString *aaa;

  @end
</code></pre></li>
</ol>


<p>NSObjct + AAA.m</p>

<pre><code>    #import "NSObject+AAA.h"
    #import &lt;objc/runtime.h&gt;

    static const void *kAAAIdentifier = (void*)@"kAAAIdentifier";

    @implementation NSObject (AAA)

    @dynamic aaa;

    - (void)setAaa:(NSString *)aaa{
            objc_setAssociatedObject(self, kAAAIdentifier, aaa, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }

    - (NSString*)aaa{
        return  objc_getAssociatedObject(self, kAAAIdentifier);
    }

    @end
</code></pre>
]]></content>
  </entry>
  
</feed>
