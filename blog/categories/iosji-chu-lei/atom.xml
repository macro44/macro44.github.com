<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios基础类 | 谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/blog/categories/iosji-chu-lei/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2015-12-05T07:52:30+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIBezierPath学习总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/"/>
    <updated>2015-12-03T17:00:10+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css"></p>

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>


<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>




<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>


<div id="category"></div>


<blockquote><p>UIBezierPath对象是CGPathRef数据类型的封装，每一个连接的直线或者去险段的集合称为subpath，一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths，使用UIBezierPath类可以创建机遇矢量的路径，使用此类可以定义简单的形状，如椭圆或者矩形，也可以定义稍微复杂的形状，如多个直线和曲线组成的形状;</p></blockquote>

<!--more-->


<h3>1.UIBezierPath的创建</h3>

<h4>1.1. + bezierPath</h4>

<pre><code>+ (instancetype)bezierPath
返回一个UIBezierPath实例;
</code></pre>

<h4>1.2. + bezierPathWithRect:</h4>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect
传入一个CGRect，构建一个矩形
</code></pre>

<h4>1.3. + bezierPathWithOvalInRect:</h4>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect
传入一个CGRect，构建一个内切椭圆
</code></pre>

<h4>1.4. + bezierPathWithRoundedRect:cornerRadius:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                         cornerRadius:(CGFloat)cornerRadius
创建一个圆角矩形，其中rect为矩形的rect，cornerRadius为圆角率
</code></pre>

<h4>1.5. + bezierPathWithRoundedRect:byRoundingCorners:cornerRadii:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                    byRoundingCorners:(UIRectCorner)corners
                          cornerRadii:(CGSize)cornerRadii
构建一个可指定圆角的矩形,其中rect为矩形的rect，corners为需要圆角的角,cornerRadii为圆角
率(sized的    组成最大不能超过宽高的一半)
</code></pre>

<h4>1.6. + bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center
                             radius:(CGFloat)radius
                         startAngle:(CGFloat)startAngle
                           endAngle:(CGFloat)endAngle
                          clockwise:(BOOL)clockwise
创建一段圆弧,center为圆弧的圆心，radius为半径,startAngle为开始弧度，endAngle为结束弧
度,clockwise为方向  (默认YES为顺时针方向，No为逆时针方向)，具体的开始点与结束点看下方参
考图  
</code></pre>

<p>其中正右顶点为起始点也为结束点,顺时针依次增加;  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120401.png" alt="参考图" /><br/>
<font color=red size=3>[注意]:</font>之所以强调顺时针方向与逆时针防线的原因是，当起始弧度与结束弧度相同的时候，不同的方向画线会得到不同的结果，如0和π/2，顺时针会得到右下部的1/4部分，但逆时针会得到上面的3/4部分;</p>

<h4>1.7. + bezierPathWithCGPath:</h4>

<pre><code>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath
用CGPath创建一个UIBezierPath
</code></pre>

<h4>1.8. - bezierPathByReversingPath</h4>

<pre><code>- (UIBezierPath *)bezierPathByReversingPath
创建一个与原bezierPath路径相同，方向相反的bezierPath对象
</code></pre>

<h3>2. 构建路径</h3>

<h4>2.1. - moveToPoint:</h4>

<pre><code>- (void)moveToPoint:(CGPoint)point
移动起始点到指定位置
</code></pre>

<h4>2.2. - addLineToPoint:</h4>

<pre><code>- (void)addLineToPoint:(CGPoint)point
从起始点增加一条线到指定的point，并在下一次改变时把point当起始点
</code></pre>

<h4>2.3. - addArcWithCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>- (void)addArcWithCenter:(CGPoint)center
              radius:(CGFloat)radius
          startAngle:(CGFloat)startAngle
            endAngle:(CGFloat)endAngle
           clockwise:(BOOL)clockwise
增加一段圆弧，center为圆弧的圆心,radius为圆弧的半径,startAngle为起始圆弧度数,endAngle
为终止圆弧度数,clockwise为是否是顺时钟，与
（+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:）
的演示图中度数的起始点和终止点相同
</code></pre>

<h4>2.4. - addQuadCurveToPoint:controlPoint:</h4>

<pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint
           controlPoint:(CGPoint)controlPoint
新增一段二阶贝塞尔曲线，其中endPoint为结束点，controlPoint为控制点
</code></pre>

<p>二阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120402.png" alt="演示图2" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.5. - addCurveToPoint:controlPoint1:controlPoint2:</h4>

<pre><code>- (void)addCurveToPoint:(CGPoint)endPoint
      controlPoint1:(CGPoint)controlPoint1
      controlPoint2:(CGPoint)controlPoint2
新增一段三阶贝塞尔曲线，其中endPoint结束点，controlPoint1为控制点1,controlPoint2为控制点2
</code></pre>

<p> 三阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120403.png" alt="演示图3" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.6. - closePath</h4>

<pre><code>- (void)closePath
用线段连接最后一个点与最初起始点，使成为一个封闭的形状
</code></pre>

<h4>2.7. - removeAllPoints</h4>

<pre><code>- (void)removeAllPoints
移除所有的点，同时也移除所有的线
</code></pre>

<h4>2.8. - appendPath:</h4>

<pre><code>- (void)appendPath:(UIBezierPath *)bezierPath
将一段路径连接到另外一段路径后面
</code></pre>

<h4>2.9. CGPath <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGPathRef CGPath
主要作用就是获取UIBezierPath的CGPathRef实例，可以用于初始化或者添加到另一个path中。
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
+ bezierPathWithCGPath:  <br/>
- appendPath:</p>

<h4>2.10. cuttrentPoint  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic, readonly) CGPoint currentPoint
主要用于获取当前的坐标点，如果当前路径为空，则当前点的值为坐标原点
</code></pre>

<h3>3. 绘图属性</h3>

<h4>3.1. lineWidth  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGFloat lineWidth
绘图线的宽度,默认为1.0
</code></pre>

<h4>3.2. lineCapStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineCap lineCapStyle
设置起点和终点的样式

enum CGLineCap{
    kCGLineCapButt,
    kCGLineCapRound,
    kCGLineCapSquare 
};
typedef enum CGLineCap CGLineCap;
</code></pre>

<h4>3.3. lineJoinStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineJoin  lineJoinStyle
设置线段连接点的样式

enum CGLineJoin{
    kCGLineJoinMiter,  
    kCGLineJoinRound,
    kCGLineJoinBevel 
}; 
typedef enum CGLineJoin CGLineCap;
</code></pre>

<h4>3.4. usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property (nonatomic) BOOL usesEvenOddFillRule
判断是否使用奇-偶规则绘图, 默认为NO,即采用非零环绕规则绘图
</code></pre>

<p><font color=orange>［名词解释］:</font> 奇－偶规则: 从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。<br/>
非零环绕规则: 首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。左边为奇－偶规则的渲染图，右边为非零环绕规则的渲染图；
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120404.png" alt="演示图4" /></p>

<h4>3.5. - setLineDash:count:phase:</h4>

<pre><code>- (void)setLineDash:(const CGFloat *)pattern
          count:(NSInteger)count
          phase:(CGFloat)phase
画一条虚线,其中pattern为一个C风格的数组，包含段点的长度，count为pattern的数量，phase为
间隔的宽度

例子:    
UIBezierPath *path = [UIBezierPath bezierPath];

path.lineWidth = 5;
path.lineJoinStyle = kCGLineJoinRound;
path.lineCapStyle = kCGLineCapRound;
[path moveToPoint:CGPointMake(100, 100)];
[path addLineToPoint:CGPointMake(200, 100)];

CGFloat a[] = {10};
[path setLineDash:a count:1 phase:5];
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015120406.png" alt="演示图5" /></p>

<h3>3.6 - getLineDash:count:phase:</h3>

<pre><code>- (void)getLineDash:(CGFloat *)pattern
          count:(NSInteger *)count
          phase:(CGFloat *)phase
获取虚线中的某一段
</code></pre>
]]></content>
  </entry>
  
</feed>
