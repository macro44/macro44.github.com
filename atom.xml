<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2016-01-25T14:12:31+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    <email><![CDATA[macro_zj@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习一门计算机语言的步骤]]></title>
    <link href="http://macro44.github.io/blog/2016/01/25/xue-xi-%5B%3F%5D-men-ji-suan-ji-yu-yan-de-bu-zou/"/>
    <updated>2016-01-25T11:05:44+08:00</updated>
    <id>http://macro44.github.io/blog/2016/01/25/xue-xi-[?]-men-ji-suan-ji-yu-yan-de-bu-zou</id>
    <content type="html"><![CDATA[<blockquote><p>你是否也有这样的困惑？当你学习在开发遇到瓶颈，想要在原有基础上扩展你的知识面，想要学习一门新的语言的时候，总感觉不知该怎么下手，然后拿本语法书从头到尾的去看基础语法-高级语法。但是过段时间之后再回忆你学过的语言的知识时，又感觉什么都没看，因为没有任何逻辑可言，同时因为跟现在的知识体系发生了冲突。感觉用起来很不自然。其实每门语言都有它的内在规律，怎么样系统的，有逻辑的去学一门计算机语言，我总结了一些浅薄的东西，希望能引起大家的思路，交流提出更多更好的学习新语言的法门。</p></blockquote>

<!--more-->


<p>只要分四大步来学习：<br/>
第一步：了解语言的一些作用，使用的场合，需要的基础，使用的流程<br/>
第二步：学习语言的语法以及与操作系统之间的关联操作<br/>
第三步：学习语言的内部以及外部调用<br/>
第四步：阶段性的Demo，综合性的Demo，主题编程</p>

<p>接下来我们详细的解释一下每一步的具体操作<br/>
<br/>
首先了解语言的一些作用，比如脚本语言可以作为独立应用脚本、游戏开发脚本、web开发脚本等，主体语言可以是创造出来什么样的东西，如oc可以创建iOS程序等等，有了这个认识之后，需要去知道什么样的场合需要用到这样的语言。比如lua，具我了解，可以作为oc的外嵌语言，起到原生程序动态修改部分内容的作用。这样，lua就可以作为ios程序的独立应用脚本，这就有了学习这门语言的原动力，然后就是需要的基础，学习这门语言需要怎么样的基本，比如oc是基于c语言的，那么学习oc的时候，最好有一些c的基础，开发的环境，需要什么样的软硬件支持，使用的流程，比如怎么样去写一个oc程序，这些都需要有一些最基本的了解。<br/>
<br/></p>

<p>其次是语言语法部分以及与操作系统的关联操作，<br/>
语言语法部分基本可以分为基本语法、变量、表达式、控制语句、函数、高级语法等部分<br/>
基本语法包括关键字、注释、基本输出等部分<br/>
高级语法包括文件IO，线程，数据库访问、错误信息处理、垃圾回收、是否面向对象、对系统的访问以及操控等<br/>
<br/></p>

<p>接着就是程序的内部调用，也可以说是内部通信，怎么样在一个文件中调用另一个文件，怎么样进行数据的共享等等，以及对动态库、静态库、以及数据库等的访问方式，还有就是与可能的其他语言的连接方式，怎么样做到统一、兼容。<br/>
<br/></p>

<p>最后需要做的就是通过阶段性Demo来综合性理解部分难以理解语法的运用。通过综合性的Demo来灵活运用语法，通过主题编程来尝试命题作文，来练习自己在整个语法过程中对语法的熟悉度。</p>

<p>下面运用一张思维图来概括
<img src="http://7xopon.com1.z0.glb.clouddn.com/2016012501.png" alt="实例图1" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua协同程序中resume和yield如何交换数据以及一个Demo的理解]]></title>
    <link href="http://macro44.github.io/blog/2016/01/18/luaxie-tong-cheng-xu-zhong-resumehe-yieldru-he-jiao-huan-shu-ju-yi-ji-%5B%3F%5D-ge-demode-li-jie/"/>
    <updated>2016-01-18T10:45:23+08:00</updated>
    <id>http://macro44.github.io/blog/2016/01/18/luaxie-tong-cheng-xu-zhong-resumehe-yieldru-he-jiao-huan-shu-ju-yi-ji-[?]-ge-demode-li-jie</id>
    <content type="html"><![CDATA[<blockquote><p>协同在Lua中的作用和线程比较类似，协同有非常强大的功能，但用起来也很复杂，其中最难理解的一部分就是协同的交换数据部分</p></blockquote>

<p>先来看一下协同的几个基本函数</p>

<table class="reference">
<tr><th>方法</th><th> 描述</th></tr>
<tr><td>coroutine.create()</td><td>
创建coroutine，返回coroutine， 参数是一个函数，当和resume配合使用的时候就唤醒函数调用</td></tr><tr><td>

coroutine.resume()</td><td>

重启coroutine，和create配合使用</td></tr><tr><td>

coroutine.yield()</td><td>

挂起coroutine，将coroutine设置为挂起状态，这个和resume配合使用能有很多有用的效果</td></tr><tr><td>

coroutine.status()</td><td>

查看coroutine的状态<br>

注：coroutine的状态有三种：dead，suspend，running，具体什么时候有这样的状态请参考下面的程序</td></tr><tr><td>

coroutine.wrap（）</td><td>

创建coroutine，返回一个函数，一旦你调用这个函数，就进入coroutine，和create功能重复</td></tr><tr><td>

coroutine.running()</td><td>

返回正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就是返回一个corouting的线程号</td></tr></table>


<p>在这些函数中一般出现交换数据的部分在resume函数与yield之间，我们来看几个例子</p>

<pre><code>--例子1
local co = coroutine.create(function(i)
         print("arg: ", i)          --①
         print("yield return: ", coroutine.yield(100, i)) --②
         print("print end")         --③   
         return "coroutine end" --④
         end)
print("resume 1: ", coroutine.resume(co, 1))  --⑥
print("resume 2: ", coroutine.resume(co, 2))  --⑦

下面是运行结果
arg:    1       --⑧
resume 1:   true    100 1   --⑨
yield return:   2   --⑩
print end       --⑪
resume 2:   true    coroutine end --⑫
</code></pre>

<p>分析程序不难发现，当运行了⑥之后，程序把变量1传入function，也就是开始执行①，之后，遇到了yield函数，程序suspended，此时resume返回三个量，true、100、1，其中true表示程序运行没有问题，100是yield的参数，1是传入的参数，也就是说，resume遇到yield的时候，会返回状态的同时返回yield的所有值，之后执行第二次resume，也就是⑦，此时接着yield的部分往下运行，从⑨⑩的顺序，特别是⑩的返回内容为2，可以发现，程序是先将第二个resume的参数传入了yield函数，让yield返回传入的参数，然后继续往下执行，我们就可以得出结论，resume遇到yield就停，并将参数传入，并通过resume返回所有的参数，第二次再resume的时候就会从yield开始运行，此时yield才第一次运行，再分析⑫的结果，此时主体函数只有④部分没有运行，所以resume返回“coroutine end”</p>

<p><strong>我们总结一下，首先resume函数开始或者继续create函数的运行，每个resume都是延续上一个协同，resume会将参数传入主体函数，同时返回。如果程序没有错误，则返回true，并返回yield的所有参数，或者是主体函数的返回值。而yield函数会使程序挂起，同时也会产生返回值，返回的是额外的传入参数</strong></p>

<p>有这个基础之后，我们来看一下一个官方的例子</p>

<pre><code>--官方Demo
 function foo (a)
   print("foo", a)
   return coroutine.yield(2*a)
 end

 co = coroutine.create(function (a,b)
       print("co-body", a, b)
       local r = foo(a+1)       ---⑨
       print("co-body", r)
       local r, s = coroutine.yield(a+b, a-b) ----⑩
       print("co-body", r, s)
       return b, "end"
 end)

 print("main", coroutine.resume(co, 1, 10))  ----①
 print("main", coroutine.resume(co, "r"))    ----②
 print("main", coroutine.resume(co, "x", "y")) ---③
 print("main", coroutine.resume(co, "x", "y")) ---④

下面是运行结果
co-body 1   10
foo 2
main    true    4  ----⑤
co-body r
main    true    11  -9 ---⑥
co-body x   y
main    true    10  end  ---⑦
main    false   cannot resume dead coroutine  ---⑧
</code></pre>

<p>怎么分析这样的程序，由入口导向，结合结果，我们先从①开始，进入coroutine.create的函数部分，然后肯定输出"co-body"这一行，接着调用foo函数，输出“foo”这一行，这时候遇到yield函数，程序挂起，resume函数返回，返回程序没有出错，所以第一个参数true，返回的应该是foo函数的结果，所以第二个参数为4，这就是我们对第一个resume的理解；</p>

<p>接着第二个resume，从⑨处开始（不知道为什么可以结合上面的例子进行理解），此时返回的是yield的参数，因为传入的是“r”，故此时r ＝ “r” 也就所有“co-body r”这一行，然后遇到yield函数，程序挂起，resume函数返回，程序运行没有出错，所以第一个参数为true，然后返回的是yield的所有参数，a= 1 ,b = 10,所以有返回的参数为"true 11 -9",这是对第二个resume的理解；</p>

<p>接着第三个resume, 从⑩开始，此时r，s分别对应着，yield函数的返回值，而返回值对应的是传入的额外的参数，也就是传入的“x”,&ldquo;y"，所以有“co-body x y”这行，然后函数结束，resume函数接收的是函数的返回值,故输出"true 10 end&rdquo;,这是对第三个resume的理解</p>

<p>接着第四个resume,因为此时函数主体已经结束了。协同的状态已经为dead了，也就是说resume发生了错误，所以返回"false cannot resume dead coroutine",这就是对第四个resume的理解</p>

<h3>参考文档</h3>

<p><a href="http://cloudwu.github.io/lua53doc/manual.html#pdf-coroutine.resume">Lua5.3参考手册</a><br/>
<a href="http://www.cnblogs.com/yjf512/archive/2012/05/28/2521412.html">Lua协同程序-轩脉刃de刀光剑影-博客</a><br/>
<a href="http://www.runoob.com/lua/lua-coroutine.html">Lua协同程序-Runoob教程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua元表(Metatable)以及元表在对象中的应用]]></title>
    <link href="http://macro44.github.io/blog/2016/01/15/luayuan-biao-metatable-yi-ji-yuan-biao-zai-dui-xiang-zhong-de-ying-yong/"/>
    <updated>2016-01-15T17:25:23+08:00</updated>
    <id>http://macro44.github.io/blog/2016/01/15/luayuan-biao-metatable-yi-ji-yuan-biao-zai-dui-xiang-zhong-de-ying-yong</id>
    <content type="html"><![CDATA[<blockquote><p>Lua table中我们可以通过访问key来获取value的值，但是却无法直接对两个table进行操作，此时我们通过元表修改操作符的行为，使其当面对一非预定义的操作时执行一个指定的操作.此行为可相较于c＋＋里面的运算符重载来看</p></blockquote>

<p>元方法使用机制:首先检测一个操作中的值是否有元素,其次这些元素是否定义了关于次操作的方法.例如,两个表a+b,首先检查两个表是否有元素，之后检查是否有一个叫"__add"的字段，若找到则，则调用对应定义的值。其定义的值一般是一个函数就是“<b>元方法</b>”</p>

<h3>设置元表以及获取元表的方法</h3>

<ul>
<li>setmetatable(table,metatable): 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</li>
<li>getmetatable(table): 返回对象的元表(metatable)。</li>
</ul>


<p>创建元表以及获取元表</p>

<pre><code>创建元表
mytable = {}
mymetatable = {}
setmetatable(mytable,mymetatable)

也可以写为
mymetatable = {}
mytable = setmetatable(mytable,mymetatable)

获取元表 
mymetatable = getmetatable(mytable) 
</code></pre>

<h3>__index元方法和__newindex元方法</h3>

<p>__index元方法用于查看表中元素是否存在,如果不存在，则返回nil，否则则由__index返回结果<br/>
__newIndex元方法向表中不存在索引赋值</p>

<pre><code>--__index元方法
tA = setmetatable({key1 = "value1"},{
    __index = function(tA,key)
        if key == key3 then
            return "value3"
        else
            retrun tA[key]
        end
    end
})

--__newindex元方法
mt = {}
tA = setmetatable({key1="value1"},{
    __newindex=mt
})

mytable.newkey = "新值2"
print(mytable.newkey,mymetatable.newkey) -- nil 新值2

mytable.key1 = "新值1"
print(mytable.key1,mymetatable.key1)  －－新值1 nil
</code></pre>

<h3>表中添加操作符</h3>

<p>__add、__sub、__mul、__div、__mod、__unm、__concat、__eq、__lt、__le</p>

<pre><code>--__add元方法
tA = {1,2,3}
tB = {4,5,6}

tM = {}
tM.__add = function(t1,t2)
    for _, item in pairs(t2) do
        table.insert(t1,item)
    end
    return t1
end

setmetatable(tA,tM)

tmun = tA + tB 

for k,v in pairs(tmun) do
    print(v)
end

--__lt元方法
tM = {}
tM.__lt = function(t1,t2)
    return #t1 &lt; #t2
end

tA = {3}
tB = {1,2}

setmetatable(tA,tM)
setmetatable(tB,tM)

print(tA &lt; tB)
</code></pre>

<h3>元方法实例</h3>

<pre><code>    Set = {}
    mt = {} --元表

    function Set.new(t)
        local set = {}
        setmetatable(set,mt)
        for _,v in pairs(t) do
            set[v] = true
        end
        return set
    end

    --tostring
    function Set.toString(set)
        local t = {}
        for s in pairs(set) do
            t[#t + 1] = s
        end
        return "{"..table.concat(t,",").."}"
        end

    function Set.print(s)
        print(Set.toString(s))
    end

    --add
    --对此方法的理解为，虚表上每一个值都有一个标志，当设置它为true时，则表明这个元素在虚表
    中存在了。
    function Set.add(t1,t2)

        if getmetatable(a) ~= mt or getmetatable(b) ~= mt then
         error("attemp to 'add' a set with a non-set value",                        2)   --error第二个参数的116
         end

        local res = Set.new{} --相当于new({})
        for k in pairs(t1) do
            res[k] = true
        end

        for k in pairs(t2) do
            res[k] = true
        end

        return res
    end

    mt.__add = Set.add

    --__sub
    function Set.sub(t1,t2)
        local res = Set.new{}
        for k in pairs(t1) do
            if t1[k] ~= t2[k] and not t2[k] then
            res[k] = true
        end 
    end
return res
end

mt.__sub = Set.sub

--__mul
function Set.mul(t1,t2)
    local res = Set.new{}
    for k in pairs(t1) do
        res[k] = t2[k]
    end
    return res
end

mt.__mul = Set.mul

--div
function Set.div(t1,t2)
    local res = Set.new()
    for k in pairs(t1) do
        if t1[k] ~=t2[k] and (not t2[k]) then
            res[k] = t1[k]
        end
    end
    return res
end

mt.__div = Set.div

--__call
function Set.call(t1,t2)
    local res = Set.new{}
    for i in pairs(t1) do
        res[i] = true
    end
    for i in pairs(t2) do
        res[i] = true
    end
    return res
end

mt.__call = Set.call

s1 = Set.new{1,2,3,4}
s2 = Set.new{5,6}

Set.print(s1(s2))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非零环绕规则以及奇偶规则]]></title>
    <link href="http://macro44.github.io/blog/2016/01/03/fei-ling-huan-rao-gui-ze-yi-ji-qi-ou-gui-ze/"/>
    <updated>2016-01-03T17:27:15+08:00</updated>
    <id>http://macro44.github.io/blog/2016/01/03/fei-ling-huan-rao-gui-ze-yi-ji-qi-ou-gui-ze</id>
    <content type="html"><![CDATA[<blockquote><p>在图形学中，判断一个点是否在多边形内部，如果多变边形各边之间不相交，那么可以很简单的判断出一个点是否在这个多边形内部，但是当这个多边形有自交边的话，那么情况就复杂了，需要应用非零环绕规则或奇－偶规则来判断。</p></blockquote>

<h3>问题由来：</h3>

<p>1.在学习<a href="https://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/">UIBezierPath</a>画路径的时候，有一个属性usesEvenOldFillRule，这个属性描述的就是是否使用奇-偶规则来渲染.<br/>
2.在学习HTML5 SVG属性的时候，碰到一个属性fill-rule，属性值可选为evenodd或者nonzero,这对应着的就是奇-偶规则和非零环绕规则.</p>

<p><b style="color:red">从上面不难看出，在涉及到多边形的图形渲染的时候，渲染规则离不开这样的判断，判断一个点或一块区域是否需要渲染。两种判断对应着两种不同的结果.</b></p>

<!--more-->


<h3>概念</h3>

<p>奇-偶规则(Odd-even Rule):奇数表示在多边形内，偶数表示在多边形外</p>

<pre><code>从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点
</code></pre>

<p>非零环绕规则(Nonzero Winding Number Rule):若环绕数为0表示在多边形外，非零表示在多边形内</p>

<pre><code>首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，
对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数
减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/201601031.gif" alt="实例图1" /><br/>
根据非零环绕规则，我们可以得出此时点在多边形内部</p>

<h3>例子:</h3>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/201601032.png" alt="实例图2" /><br/>
左边演示的是奇偶规则渲染，可以看到此时图形内演示的点在所做的射线相交的边的数量为偶数，此时，通过奇－偶规则判断这个点在图形外部。依次可以类推至图形的任意点。<br/>
右边演示的是非零环绕规则渲染。可以看到此时图中演示的点所相交的点的环绕数为2，所以此部分需要渲染，依次可以推断图形内的其他点。 <br/>
<br/>
另一个例子:<br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/201601033.png" alt="实例图3" /></p>

<h3>结论:</h3>

<p><strong>两种规则得到最后的渲染结果是不一样的。所以在实际应用的过程中一定需要根据实际需求来选择不同的规则来渲染。</strong></p>

<h3>参考:</h3>

<p><a href="http://blog.csdn.net/freshforiphone/article/details/8273023">http://blog.csdn.net/freshforiphone/article/details/8273023</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sqlite系统化学习之基础语法]]></title>
    <link href="http://macro44.github.io/blog/2015/12/21/sqlitexi-tong-hua-xue-xi-zhi-ji-chu-yu-fa/"/>
    <updated>2015-12-21T15:07:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/21/sqlitexi-tong-hua-xue-xi-zhi-ji-chu-yu-fa</id>
    <content type="html"><![CDATA[<blockquote><p>之前在项目中使用sqlite的时候，都是使用现成的基本框架，没有具体细致的去了解sqlite的从无到有的使用，最近有时间看一下sqlite语法，分为两个部分来总结一下sqlite的语法，第一部分主要用来写一些sqlite语法。主要分为两篇，这是之一，基础语法篇，还有一篇高级语法篇。第二部分用来分析在iOS项目中sqlite框架的构成，以及基本使用。</p></blockquote>

<!--more-->


<p>本教程目录：</p>

<script>
function alertWarming(){
    alert("因为本部分在iOS上用不上，所以忽略！");
}
function backToMenu(){
    window.scrollTo(0,100);
}

function mOver(obj){
    var x=document.getElementById("dataList");
    x.style.visibility='visible';
}

function mOut(obj){
    var x=document.getElementById("dataList");
    x.style.visibility='hidden';
}
</script>




<dl>
    <dt><a href=#1.1>1. SQLite数据类型</a></dt>
        <dd><a href=#1.1>1.1 SQLite存储类</a><br/>    
            <a href=#1.2>1.2 Boolean数据类型</a><br/>
            <a href=#1.3>1.3 Date与Time数据类型</a><br/>
            <a href=#1.4>1.4 SQLite 亲和(Affinity)类型</a>
        </dd>
    <dt><a href=#2.1 onclick="alertWarming()">2. SQLite数据库</a><br/></dt>
        <dd><a href=#2.1 onclick="alertWarming()">2.1 SQLite创建数据库</a><br/>
            <a href=#2.2 onclick="alertWarming()">2.2 SQLite关联数据库</a><br/>
            <a href=#2.3 onclick="alertWarming()">2.3 SQLite分离数据库</a>
        </dd>
        
    <dt><a href=#3.1>3. SQLite 表</a><br/></dt>
        <dd><a href=#3.1>3.1 SQLite创建表</a></br>
            <a href=#3.2>3.2 SQLite删除表</a>
        </dd>
        
    <dt><a href=#4.1>4. SQLite 运算符</a></dt>
        <dd><a href=#4.1>4.1 算数运算符</a><br/>
            <a href=#4.2>4.2 比较运算符</a><br/>
            <a href=#4.3>4.3 逻辑运算符</a><br/>
            <a href=#4.4>4.4 位运算符</a>
        </dd>
    </dt>   
    
    <dt><a href=#5.1>5. SQLite 表达式</a></dt>
        <dd><a href=#5.1>5.1 基本查询语句</a><br/>
            <a href=#5.2>5.2 布尔表达式</a><br/>
            <a href=#5.3>5.3 数值表达式</a><br/>
            <a href=#5.4>5.4 日期表达式</a><br/>
        </dd>
        
    <dt><a href=#6.1>6. SQLite 关键字子句</a></dt>
        <dd><a href=#6.1>6.1 Where子句</a><br/>
            <a href=#6.2>6.2 And/Or子句</a><br/>
            <a href=#6.3>6.3 Like子句</a><br/>
            <a href=#6.4>6.4 Glob子句</a><br/>
            <a href=#6.5>6.5 Limit子句</a><br/>
            <a href=#6.6>6.6 Order By子句</a><br/>
            <a href=#6.7>6.7 Group By子句</a><br/>
            <a href=#6.8>6.8 Having子句</a><br/>
            <a href=#6.9>6.9 Distinct关键字</a><br/>
        </dd>
        
    <dt><a href=#7.1>7. SQL基本操作</a><br/></dt>
        <dd><a href=#7.1>7.1 SQL Insert语句</a><br/>
            <a href=#7.2>7.2 SQL Delete语句</a><br/>
            <a href=#7.3>7.3 SQL Update语句</a><br/>
            <a href=#7.4>7.4 SQL Select语句</a>
        </dd>
</dl>


<blockquote><p>提示:本基础语法篇的例子都是基于<a href=#0>附录数据表</a></p></blockquote>

<p><a id=1.1>1.1 SQLite存储类</a></p>

<table border=1 cellspacing=0 style="text-algn:center">
<tr>
    <th width=20%>存储类</th>
    <th width=80%>描述</th>
</tr>
<tr> 
    <td>NULL</td>
    <td>值是一个NULL值.</td>
</tr>
<tr>
    <td>INTEGER</td>
    <td>值是一个带符号的整形，根据值的大小存储在1、2、3、4、6、8字节中</td>
</tr>
<tr>
    <td>REAL</td>
    <td>值是一个浮点值,存储为8字节点的IEE浮点数字</td>
</tr>
<tr>
    <td>TEXT</td>
    <td>值是一个文本字符串</td>
</tr>
<tr>
    <td>BLOB</td>
    <td>用于存储blob数据段，如图片、语音、视频等</td>
</tr>
</table>


<p><a id=1.2>1.2 Boolean数据类型</a><br/>
    Sqlite没有单独的Boolean存储类,布尔值被存储为整数0和1</p>

<p><a id=1.3>1.3 Date与Time数据类型</a><br/>
SQLite没有单独的用语存储日期或时间的存储类，但是SQLite能够把日期和时间存储为TEXT、REAL或INTEGER值.</p>

<table border=1 cellspacing=0 style="text-algn:center">
<tr>
    <th width=20%>存储类</th>
    <th width=100%>日期格式</th>
</tr>
<tr> 
    <td>TEXT</td>
    <td>格式为"YYYY-MM-DD HH:MM:SS.SSS"的日期</td>
</tr>
<tr>
    <td>REAL</td>
    <td>从公元前4714年11月24日格林尼治的正午开始算起的天数</td>
</tr>
<tr>
    <td>INTEGER</td>
    <td>从1970-01－01 00:00:00 UTC算起的秒数.</td>
</tr>
</table>


<p><a id=1.4>1.4 SQLite 亲和(Affinity)类型</a></p>

<table border='1' cellspacing="0" style="text-align:center">
<tr>
    <th>Affinity</th>
    <th>描述</th>
</tr>
<tr>
    <td>TEXT</td>
    <td>该列使用存储类NULL、TEXT或BLOB存储所有数据</td>
</tr>
<tr>
    <td>NUMERIC</td>
    <td>该列可以包含使用所有五个存储类的值。</td>
</tr>
<tr>
    <td>INTEGER</td>
    <td>与带有 NUMERIC affinity 的列相同，在 CAST 表达式中带有异常。</td>
</tr>
<tr>
    <td>REAL</td>
    <td>与带有 NUMERIC affinity 的列相似，不同的是，它会强制把整数值转换为浮点表示。</td>
</tr>
<tr>
    <td>NONE</td>
    <td>    带有 affinity NONE 的列，不会优先使用哪个存储类，也不会尝试把数据从一个存储类强制转换为另一个存储类。</td>
</tr>
</table>


<p>Affinity类型每一种包含的具体类型参照表:</p>

<div align="center">
<table border='1' cellspacing="0" style="text-align:center">
<tr>
    <th width=80%>数据类型</th>
    <th width=30%>Affinity</th>
<tr>
<tr>
    <td>
        <ul>
            <li>INT</li>
            <li>INTEGER</li>
            <li>TINYINT</li>
            <li>SMALLINT</li>
            <li>MEDIUMINT</li>
            <li>BIGINT</li>
            <li>UNSIGNED BIG INT</li>
            <li>INT2</li>
            <li>INT8</li>
        </ul>
    </td>
    <td>INTEGER</td>
</tr>
<tr>
    <td>
        <ul>
            <li>CHARACTER(20)</li>
            <li>VARCHAR(255)</li>
            <li>VARYING CHARACTER(255)</li>
            <li>NCHAR(55)</li>
            <li>NATIVE CHARACTER(70)</li>
            <li>NVARCHAR(100)</li>
            <li>TEXT</li>
            <li>CLOB</li>
         </ul>
    </td>
    <td>TEXT</td>
</tr>
<tr>
    <td>
        <ul>
            <li>BLOB</li>
            <li>no datatype specified</li>
        </ul>
    </td>
    <td>NONE</td>
</tr>
<tr>
    <td>
        <ul>
            <li>REAL</li>
            <li>DOUBLE</li>
            <li>DOUBLE PRECISION</li>
            <li>FLOAT</li>
        </ul>
    </td>
    <td>REAL</td>
</tr>
<tr>
    <td>
        <ul>
            <li>NUMERIC</li>
            <li>DECIMAL(10,5)</li>
            <li>BOOLEAN</li>
            <li>DATE</li>
            <li>DATETIME</li>
        </ul>
    </td>
    <td>NUMERIC</td>
</tr>
</table>
</div>


<p><br/>
<a id=2.1>2.1 SQLite创建数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=2.2>2.2 SQLite关联数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=2.3>2.3 SQLite分离数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=3.1>3.1 SQLite创建表</a><br></p>

<pre><code>基本语法结构: CREATE TABLE table_name(
                column1  datatype,
                ...
            );
</code></pre>

<p><a id=3.2>3.2 SQLite删除表</a><br/></p>

<pre><code>基本语法结构: DROP TABLE table_name;
</code></pre>

<p><font color=red size=3>**使用此命令需注意，一旦表删除，表中的信息也将永久删除**</font></p>

<p><a id=4.1>4.1 算数运算符</a><br/></p>

<table border="1" cellspacing="0">
<tr>
    <th style="width:20%">运算符
    </th>
    <th style="width:45%">描述
    </th>
    <th>实例
    </th>
</tr>
<tr>
    <td>+</td>
    <td>加法 - 把运算符两边的值相加</td>
    <td> a + b 将得到 30</td>
</tr>
<tr>
    <td>-</td><td>减法 - 左操作数减去右操作数</td>
    <td> a - b 将得到 -10</td>
</tr>
<tr>
    <td>*</td>
    <td>乘法 - 把运算符两边的值相乘</td>
    <td> a * b 将得到 200</td>
</tr>
<tr>
    <td>/</td>
    <td>除法 - 左操作数除以右操作数</td>
    <td> b / a 将得到 2</td>
</tr>
<tr>
    <td>%</td>
    <td>取模 - 左操作数除以右操作数后得到的余数</td>
    <td> b % a将得到 0</td>
</tr>
</table>


<p><a id=4.2>4.2 比较运算符</a><br/></p>

<table border=1 cellspacing=0>
<tbody>
<tr>
    <th style="width:20%">运算符</th>
    <th style="width:45%">描述</th>
    <th>实例</th>
</tr>
<tr>
    <td>==</td>
    <td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
    <td> (a == b) 不为真。</td>
</tr>
<tr>
    <td>=</td>
    <td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
    <td> (a = b) 不为真。</td>
</tr>
<tr>
    <td>!=</td>
    <td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
    <td> (a != b) 为真。</td>
</tr>
<tr>
    <td>&lt;&gt;</td>
    <td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
    <td> (a &lt;&gt; b) 为真。</td>
</tr>
<tr>
    <td>&gt;</td>
    <td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
    <td> (a &gt; b) 不为真。</td>
</tr>
<tr>
    <td>&lt;</td>
    <td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
    <td> (a &lt; b) 为真。</td>
</tr>
<tr>
    <td>&gt;=</td>
    <td>检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
    <td> (a &gt;= b) 不为真。</td>
</tr>
<tr>
    <td>&lt;=</td>
    <td>检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
    <td> (a &lt;= b) 为真。</td>
</tr>
<tr>
    <td>!&lt;</td>
    <td>检查左操作数的值是否不小于右操作数的值，如果是则条件为真。</td>
    <td> (a !&lt; b) 为假。</td>
</tr>
<tr>
    <td>!&gt;</td>
    <td>检查左操作数的值是否不大于右操作数的值，如果是则条件为真。</td>
    <td> (a !&gt; b) 为真。</td>
</tr>
</table>


<p><a id=4.3>4.3 逻辑运算符</a><br/></p>

<table border=1 cellspacing=0>
<tr>
    <th style="width:20%">运算符</th>
    <th style="width:80%">描述</th>
</tr>
<tr>
    <td>AND</td>
    <td>AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。</td>
</tr>
<tr>
    <td>BETWEEN</td>
    <td>BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</td>
</tr>
<tr>
    <td>EXISTS</td>
    <td>EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</td>
</tr>
<tr>
    <td>IN</td>
    <td>IN 运算符用于把某个值与一系列指定列表的值进行比较。</td>
</tr>
<tr>
    <td>NOT IN</td>
    <td>IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</td>
</tr>
<tr>
    <td>LIKE</td>
    <td>LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</td>
</tr>
<tr>
    <td>GLOB</td>
    <td>GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。</td>
</tr>
<tr>
    <td>NOT</td>
    <td>NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。<b>它是否定运算符。</b></td>
</tr>
<tr>
    <td>OR</td>
    <td>OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</td>
</tr>
<tr>
    <td>IS NULL</td>
    <td>NULL 运算符用于把某个值与 NULL 值进行比较。</td>
</tr>
<tr>
    <td>IS</td>
    <td>IS 运算符与 = 相似。</td>
</tr>
<tr>
    <td>IS NOT</td>
    <td>IS NOT 运算符与 != 相似。</td>
</tr>
<tr>
    <td>||</td>
    <td>连接两个不同的字符串，得到一个新的字符串。</td>
</tr>
<tr>
    <td>UNIQUE</td>
    <td>UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</td>
</tr>
</table>


<p><font color=red>**需要注意的是,exists运算符返回的是条件满足的表的所有数据，而不是指定数据行，一定要注意理解!**</font></p>

<p><a id=4.4>4.4 位运算符</a><br/></p>

<table border=1 cellspacing=0>
<tr>
    <th width="20%">运算符</th>
    <th width="45%">描述</th>
    <th>实例</th>
</tr>
<tr>
    <td>&amp;</td>
    <td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
    <td> (A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
    <td>|</td>
    <td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
    <td> (A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
    <td>~</td>
    <td>二进制补码运算符是一元运算符，具有"翻转"位效应。</td>
    <td> (~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td>
</tr>
<tr>
    <td>&lt;&lt;</td>
    <td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
    <td> A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
    <td>&gt;&gt;</td>
    <td> 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
    <td> A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</table>


<p><a id=5.1>5.1 基本查询语句</a><br/></p>

<pre><code>基本语法:
SELECT column1, column2, columnN 
FROM table_name 
WHERE [CONTION | EXPRESSION];
</code></pre>

<p><span  style="color:red">[例子]:</span>SELECT * FROM company;</p>

<p><a id=5.2>5.2 布尔表达式</a><br/></p>

<pre><code>基本语法:
SELECT column1, column2, columnN 
FROM table_name 
WHERE SINGLE VALUE MATCHTING EXPRESSION;
</code></pre>

<p>此部分应结合<a href=#4.2>比较运算符</a>一起看;</p>

<div><span style="color:red">[例子]:</span> SELECT * FROM company WHERE salary=20000;</div>


<p><a id=5.3>5.3 数值表达式</a><br/></p>

<pre><code>基本语法:
SELECT numerical_expression as  OPERATION_NAME
[FROM table_name WHERE CONDITION] ;

其实最常用的还是几个内置的函数 avg() sum() count()d等等；
</code></pre>

<div><span style="color:red">[例子]:</span>SELECT COUNT(*) FROM company;</div>


<p><a id=5.4>5.4 日期表达式</a><br/></p>

<pre><code>被用作返回系统当前日期和时间值;
基本语法：
SELECT CURRENT_TIMESTAMP；
</code></pre>

<p><a id=6.1>6.1 Where子句</a><br/></p>

<pre><code>基本语法：
SELECT column1, column2, columnN 
FROM table_name
WHERE [condition]
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT * FROM company WHERE age=32;</div>


<p>
<a id=6.2>6.2 And/Or子句</a><br/></p>

<pre><code>基本语法：
SELECT column1, column2, columnN 
FROM table_name
WHERE [condition1] AND／OR [condition2]...OR [conditionN];
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT * FROM company WHERE age=32 And    salary>30000;<br/>
    SELECT * FROM company WHERE age=32 OR salary>30000;
</div>


<p><a id=6.3>6.3 Like子句</a><br/></p>

<pre><code>SQLite的like运算符是用来匹配通配符指定模式的文本值。如果搜索结果与符合like表达式的指定的模
式，like运算符将返回真（1），否则为假（0）; 

通配符：
        百分号( % ): 代表零个、一个或多个数字或字符。
        下划线( _ ): 代表单个数字或字符.

基本语法:
        SELECT FROM table_name WHERE column LIKE 'XXXX%'

        or 

        SELECT FROM table_name WHERE column LIKE '%XXXX%'

        or

        SELECT FROM table_name WHERE column LIKE 'XXXX_'

        or

        SELECT FROM table_name WHERE column LIKE '_XXXX'

        or

        SELECT FROM table_name WHERE column LIKE '_XXXX_'
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT * FROM company WHERE age like '2%';</div>


<p><a id=6.4>6.4 Glob子句</a><br/></p>

<pre><code>SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB
运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通
配符，它遵循 UNIX 的语法。

通配符: 
        星号( * ): 代表零个、一个或多个数字或字符.
        问好( ? ): 代表单个数字或字符.

基本语法：
        SELECT FROM table_name WHERE column GLOB 'XXXX*'

        or 

        SELECT FROM table_name WHERE column GLOB '*XXXX*'

        or

        SELECT FROM table_name WHERE column GLOB 'XXXX?'

        or

        SELECT FROM table_name WHERE column GLOB '?XXXX'

        or

        SELECT FROM table_name WHERE column GLOB '?XXXX?'

        or

        SELECT FROM table_name WHERE column GLOB '????'
</code></pre>

<p><a id=6.5>6.5 Limit子句</a><br/></p>

<pre><code>基本语法:
SELECT column1, column2, columnN 
FROM table_name
LIMIT [no of rows]

与Offset子句一起使用的语法:
SELECT column1, column2, columnN 
FROM table_name
LIMIT [no of rows] OFFSET [row num]
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT * FROM company LIMIT 3;<br/>
SELECT * FROM company LIMIT 3 OFFSET 2;
</div>


<p><a id=6.6>6.6 Order By子句</a><br/></p>

<pre><code>用于基于一个或多个列按升序或降序排列数据；

基本语法：
        SELECT column-list 
        FROM table_name 
        [WHERE condition] 
        [ORDER BY column1, column2, .. columnN] [ASC | DESC];
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT * FROM company ORDER BY salary ASC ,age DESC;
</div>


<p></p>

<p><a id=6.7>6.7 Group By子句</a><br/></p>

<pre><code>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。
在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。

基本语法:
        SELECT column-list
        FROM table_name
        WHERE [ conditions ]
        GROUP BY column1, column2....columnN
        ORDER BY column1, column2....columnN
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT name,sum(salary) FROM company GROUP BY name ORDER BY salary ASC;
</div>


<p></p>

<p><a id=6.8>6.8 Having子句</a><br/></p>

<pre><code>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，
而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件

基本语法：
        SELECT column1, column2
        FROM table1, table2
        WHERE [ conditions ]
        GROUP BY column1, column2
        HAVING [ conditions ]
        ORDER BY column1, column2
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT name,sum(salary) FROM company GROUP BY name HAVING count(name) < 2 ORDER BY salary ASC;
</div>


<p></p>

<p><a id=6.9>6.9 Distinct关键字</a><br/></p>

<pre><code>SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记
录。有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得
特别有意义，它只获取唯一一次记录，而不是获取重复记录。

基本语法:
        SELECT DISTINCT column1, column2,.....columnN 
        FROM table_name
        WHERE [condition]
</code></pre>

<div><span style="color:red">[例子]:</span> SELECT DISTINCT name FROM company;
</div>


<p><a id=7.1>7.1 SQL Insert语句</a><br/></p>

<pre><code>基本语法:INSERT INTO TABLE_NAME (column1,...columnN) VALUES (value1,...valueN);
当要为表中所有列添加值，这时可以不用指定列名称,此时语法结构可以为:
INSERT INTO TABLE_NAME VALUES (value1, ...valueN);
</code></pre>

<p><a id=7.2>7.2 SQL Delete语句</a><br/></p>

<pre><code>基本语法结构:DELETE FROM table_name WHERE [condition];        
</code></pre>

<p><a id=7.3>7.3 SQL Update语句</a><br/></p>

<pre><code>基本语法结构:UPDATE table_name SET column1 = value1...., columnN = valueN 
WHERE [condition];
</code></pre>

<p><a id=7.4>7.4 SQL Select语句</a></p>

<pre><code>基本语法结构:SELECT column1, column2,... columnN FROM table_name;
如果要查询所有的数据，可以用 select * from table_name;
</code></pre>

<p><a id=0>附录数据表(一):</a><input type="button" value="返回顶部" onclick=backToMenu()></p>

<pre><code>id          name        age         address     salary    
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0   
2           Allen       25          Texas       15000.0   
3           Teddy       23          Norway      20000.0   
4           Mark        25          Rich-Mod    65000.0   
5           David       27          Texas       85000.0   
6           Kim         22          South-Hall  45000.0 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML基础标签总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/16/htmlji-chu-biao-qian-zong-jie/"/>
    <updated>2015-12-16T10:31:14+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/16/htmlji-chu-biao-qian-zong-jie</id>
    <content type="html"><![CDATA[<blockquote><p>离不开H5，就尽情的享受HTML带来的方便。学H5，从基本的HTML开始；</p></blockquote>

<h3>目录:</h3>

<p><a href=#1>1. HTML基本文档</a><br/>
<a href=#2>2. HTML基本标签</a><br/>
<a href=#3>3. HTML文本格式化</a><br/>
<a href=#4>4. 链接</a><br/>
<a href=#5>5. 样式/区块</a><br/>
<a href=#6>6. 表格</a><br/>
<a href=#7>7. 列表</a><br/>
<a href=#8>8. 框架</a><br/>
<a href=#9>9. 表单</a><br/>
<a href=#10>10. 实体</a><br/></p>

<!--more-->


<p><a id=1>1. HTML基本文档</a></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;文档标题&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
文本...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><a id=2>2. HTML基本标签</a><br/></p>

<pre><code>&lt;h1&gt;这是一级标题&lt;/h1&gt;
&lt;h2&gt;这是二级标题&lt;/h2&gt;
&lt;h3&gt;这是三级标题&lt;/h3&gt;
...
&lt;h6&gt;这是最小的标题&lt;/h6&gt;
&lt;p&gt;这是一个段落&lt;/p&gt;
&lt;br/&gt;  换行
&lt;hr/&gt;  水平线
&lt;!--这是注释--&gt;
</code></pre>

<p><a id=3>3. HTML文本格式化</a><br/></p>

<pre><code>&lt;b&gt;粗体文本&lt;/b&gt;
&lt;i&gt;斜体文本&lt;/i&gt;
&lt;strong&gt;加重语气－粗体显示&lt;/strong&gt;
&lt;em&gt;着重语气-斜体显示&lt;/em&gt;
&lt;small&gt;更小的文本&lt;/small&gt;
&lt;sub&gt;定义下标字&lt;/sub&gt;
&lt;sup&gt;定义上标字&lt;/sup&gt;
&lt;ins&gt;定义删除字&lt;/ins&gt;
&lt;del&gt;定义下划线&lt;del&gt;

&lt;code&gt;计算机代码&lt;/code&gt;
&lt;kbd&gt;键盘输入&lt;/kbd&gt;
&lt;samp&gt;计算机代码样本&lt;/samp&gt;
&lt;var&gt;定义变量&lt;/var&gt;
&lt;pre&gt;预格式文本&lt;/pre&gt;

&lt;abbr&gt;定义缩写&lt;/abbr&gt;
&lt;address&gt;定义地址&lt;/address&gt;
&lt;bdo&gt;定义文本的方向&lt;/bdo&gt;
&lt;q&gt;短引用&lt;/q&gt;
&lt;blockquote&gt;从另一个源引用的部分&lt;/blockquote&gt;
&lt;cite&gt;一般与blockquote连用，用来表示引用的源&lt;/cite&gt;
</code></pre>

<p><a id=4>4. 链接</a><br/></p>

<pre><code>普通的链接: &lt;a href="url"&gt;链接文本&lt;/a&gt;
图片: &lt;img src="url" alt="替换文本" height="高" width="宽"&gt;
图片链接: &lt;a href="url"&gt;&lt;img src="url" alt="替换文本"&gt;&lt;/a&gt;
邮件链接:    &lt;a href="mailto:mail_xxx@example.com"&gt;发送Email&lt;/a&gt;
书签: &lt;a id="tips"&gt;提示部分&lt;/a&gt;
    &lt;a href="#tips"&gt;跳转到提示部分&lt;/a&gt;
</code></pre>

<p><a id=5>5. 样式/区块</a><br/></p>

<pre><code>样式写法(一):
&lt;style type="text/css"&gt;
body {background-color:yellow;}
h1 {color:red;text-align:center;}
p  {color:green;}
&lt;/style&gt;    

样式写法(二):
&lt;body style="background-color:red;text-align:center;"&gt;...&lt;/body&gt;

样式写法(三):
&lt;link rel="当前文档与被链接文档之间的关系" type="text/css" href="url"&gt;

区块:主要功能是将页面模块分化，每一个模块有每一个模块的样式，方便进行处理
&lt;div&gt;块级元素&lt;/div&gt;

&lt;span&gt;内联元素&lt;/span&gt;
</code></pre>

<p><a id=6>6. 表格</a><br/></p>

<pre><code>&lt;table border="边宽"&gt;&lt;/table&gt;
&lt;caption&gt;表的标题&lt;/caption&gt;
&lt;tr&gt;定义一行&lt;/tr&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;td&gt;元素&lt;/td&gt;
colspan表示可跨越的列数
rowspan表示可跨越的行数
cellspacing 表示表格与表格边缘的距离

例子：
&lt;table border="1" style="text-align:center" cellspacing="0"&gt;
&lt;caption&gt;表格Demo&lt;/caption&gt;
&lt;tr&gt;
    &lt;th&gt;A&lt;/th&gt;
    &lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td colspan="2"&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<table border="1" style="text-align:center" cellspacing="0">
<caption>表格Demo</caption>
<tr>
    <th>A</th>
    <th>B</th>
</tr>
<tr>
    <td colspan="2">a</td>
</tr>
</table>


<p><a id=7>7. 列表</a><br/></p>

<pre><code>&lt;ol&gt;定义有序列表&lt;/ol&gt;
&lt;ul&gt;定义无序列表&lt;/ul&gt;
&lt;dl&gt;定义自定义列表&lt;/dl&gt;
&lt;dt&gt;自定义列表项目&lt;/dt&gt;
&lt;dd&gt;自定义列表的描述&lt;/dd&gt;
type 表示列表的类型

有序列表
&lt;ol type="1" start="50"&gt;
    &lt;li&gt;第一项&lt;/li&gt;
    &lt;li&gt;第二项&lt;/li&gt;
    &lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;

无序列表
&lt;ul&gt;
    &lt;li&gt;第一项&lt;/li&gt;
    &lt;li&gt;第二项&lt;/li&gt;
&lt;/ul&gt;

自定义列表 
&lt;dl&gt;
    &lt;dt&gt;项目名1&lt;/dt&gt;
        &lt;dd&gt;项目名描述1&lt;/dd&gt;
    &lt;dt&gt;项目名2&lt;/dt&gt;
        &lt;dd&gt;项目描述2&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>

<ol type="a" start="3">
        <li>第一项</li>
        <li>第二项</li>
        <li>第三项</li>
    </ol>


<p><a id=8>8. 框架</a><br/></p>

<pre><code>&lt;iframe src="url" width="宽" height="高" name="名称"&gt;定义框架&lt;/iframe&gt;
</code></pre>

<p><a id=9>9. 表单</a><br/></p>

<pre><code>&lt;form&gt;表单元素&lt;/form&gt;
&lt;input type="类型"&gt;输入&lt;/input&gt;
&lt;textarea&gt;文本框&lt;/textarea&gt;
&lt;label&gt;为 input 元素定义标注&lt;/label&gt;
&lt;fieldset&gt;在相关表单元素周围绘制边框/fieldset&gt;
&lt;legend&gt;为&lt;fieldset&gt;元素定义标题&lt;/legend&gt;
&lt;select&gt;下拉选项列表&lt;/select&gt;
&lt;optgroup&gt;定义选项组&lt;/optgroup&gt;
&lt;option&gt;&lt;select&gt;的选项&lt;/option&gt;
&lt;button&gt;定义一个按钮&lt;/button&gt;
&lt;datalist&gt;定义一个&lt;input&gt;元素可能选项列表&lt;/datalist&gt;
&lt;output&gt;定义一个计算结果&lt;/output&gt;

&lt;form&gt;
&lt;fieldset&gt;
&lt;legend&gt;表单DEMO&lt;/legend&gt;
输入框: &lt;input type="text" name="user"&gt;&lt;br/&gt;
密码框: &lt;input type="password" name="pwd"&gt;&lt;br/&gt;
单选框: &lt;input type="radio" name="singleChoose" value="1"&gt;&lt;br/&gt;
复选框: &lt;input type="checkbox" name="muilChoose" value="1"&gt;&lt;br/&gt;
提交按钮: &lt;input type="submit" value="提交"&gt;&lt;br/&gt;
下拉列表: &lt;select&gt;
    &lt;optgroup label="分类1"&gt;
            &lt;option value="1"&gt;1&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="分类2" disabled&gt;
            &lt;option value="2" selected&gt;2&lt;/option&gt;       &lt;/optgroup&gt;
    &lt;/select&gt;&lt;br/&gt;
文本框: &lt;textarea rows="2" cols="30"&gt;我是一个文本框&lt;/textarea&gt;
按钮: &lt;input type="button" value="按钮"&gt;或者&lt;button type="button"&gt;click&lt;/button&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>

<p><fieldset>
    <legend>表单DEMO</legend>
输入框: <input type="text" name="user"><br/>
密码框: <input type="password" name="pwd"><br/>
单选框: <input type="radio" name="singleChoose" value="1"><br/>
复选框: <input type="checkbox" name="muilChoose" value="1"><br/>
提交按钮: <input type="submit" value="提交"><br/>
下拉列表: <select>
        <optgroup label="分类1">
                <option value="1">1</option>
        </optgroup>
        <optgroup label="分类2" disabled>
                <option value="2" selected>2</option>       </optgroup>
        </select><br/>
文本框: <textarea rows="2" cols="30">我是一个文本框</textarea><br/>
按钮: <input type="button" value="按钮"><br/>
<button type="button">click</button>
</fieldset></p>

<p><a id=10>10. 实体</a><br/></p>

<pre><code>&lt; &amp;lt; &amp;#60;
&gt; $gt; &amp;#62;
© &amp;#169;
</code></pre>

<p><a href="http://www.runoob.com/html/html-tutorial.html" style="text-decoration:none;" target="_blank">Runoob教程链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(二)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er/"/>
    <updated>2015-12-14T18:11:05+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS可执行文件瘦身方法</font></div>


<blockquote><p>在第一部分中，我们已经介绍了如何获取可执行文件组成列表，以及如何查看静态链接库的占比的方法。这一部分我们将来仔细介绍可执行文件瘦身的具体方法；</p></blockquote>

<p><a href="http://blog.cnbang.net/tech/2544/">转载于bang&rsquo;s blog</a>
</br></p>

<!--more-->


<h3>编译选项</h3>

<ol>
<li>编译器优化级别
Build Settings->Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</li>
<li><p>去除符号信息
Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，详细信息见<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-97021-TPXREF121">官方文档</a>。</p>

<p>  这些选项目前都是XCode里release的默认选项，但旧版XCode生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/legacy/library/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.pdf">CodeFootprint.pdf</a></p></li>
</ol>


<h3>第三方库统计</h3>

<p>通过<a href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/">(一)</a>中对可执行文件的分析可以知道第三方库的占比，从而判断是否值得去找可执行方案去替换掉这个第三方库，转载作者写了一个node.js脚本，可以通过linkmap去统计每个.o目标文件占用的体积和每个.a静态库占用的体积.具体在<a href="https://gist.github.com/bang590/8f3e9704f1c2661836cd">详见这里</a></p>

<h3>ARC ->MRC</h3>

<p>具体没看懂，知道结论是可减少资源包的8%左右，有兴趣的可查看<a href="http://blog.cnbang.net/tech/2544/">原文</a>,但是这样程序的维护成本就上升了，如果没有特殊情况，一般不建议使用.</p>

<h3>无用代码</h3>

<p>在项目里新建一个类，给它添加几个方法，但不要在任何地方import它，build完项目后观察linkmap，你会发现这个类还是被编译进可执行文件了。
按C++的经验，没有被使用到的类和方法编译器都会优化掉，不会编进最终的可执行文件，但object-c不一样，因为object-c的动态特性，它可以通过类和方法名反射获得这个类和方法进行调用，所以就算在代码里某个类没被使用到，编译器也没法保证这个类不会在运行时通过反射去调用，所以只要是在项目里的文件，无论是否又被使用到都会被编译进可执行文件。
对此我们可以通过脚本，遍历整个项目的文件，找出所有没有被引用的类文件和没有被调用的方法，在保证没有其他地方动态调用的情况下把它们去掉。如果整个项目历时很长，历时代码遗留较多，这个清理对可执行文件省出的空间还是挺可观的。</p>

<h3>类/方法名的长度</h3>

<p>观察linkmap可以发现每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来。
对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩js一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它class-dump出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行hack。不过这样做有个缺点，就是crash堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆->原名的转换，实现和使用成本有点高。
实际上这部分占用的长度比较小，中型项目也就几百K，对安全性要求高的情况可以试试。</p>

<h3>冗余字符串</h3>

<p>代码上定义的所有静态字符串都会记录在在可执行文件的__cstring段，如果项目里Log非常多，这个空间占用也是可观的，也有几百K的大小，可以考虑清理所有冗余的字符串。另外如果有特别长的字符串，建议抽离保存成静态文件，因为AppStore对可执行文件加密导致压缩率低，特别长的字符串抽离成静态资源文件后压缩率会比在可执行文件里高很多。</p>

<h3>列一个清单</h3>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015121403.png" alt="效果展示" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/"/>
    <updated>2015-12-14T16:17:28+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-[?]</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS App可执行文件的组成</font></div>


<blockquote><p>面试的时候遇到的面试题，如何给App瘦身，之前有看过类似的题目，讲的大概就是两个方面，一、给资源文件瘦身，2、能下载处理的尽量通过后续下载来处理。但没有实际操作过。所以总感觉回答的不是那么个味道。回来问同事以及查资料后果然，需要两个方面来瘦身：1、减少资源包的大小；2、减少可执行文件的大小。1在本博客后续博客中会提到如何瘦身，本文主要讲解可执行文件瘦身的一部分，App可执行文件的组成；</p></blockquote>

<!--more-->


<p><a href="http://blog.cnbang.net/tech/2296/">转载于bang&rsquo;s blog </a></p>

<h3>查看App可执行文件组成的方法</h3>

<ol>
<li><p>XCode开启编译选项Write Link Map File
Xcode -> Project -> Build Setting ->搜索map ->设置Write Link Map File为Yes<br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121401.png" alt="展示图片" /></p></li>
<li><p>编译后，通过路径查找找到图中txt文件对应的文件
具体路径: ~/Library/Developer/Xcode/DerivedData/XXX-xxxxxxxxxxxx/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/XXX-LinkMap-xxx.txt<br/>
（这个LinkMap展示了整个App中可执行文件的全貌，列出了编译后的每一个.o文件，包括.a文件里的，以及每一个目标文件的代码段，数据段存储详情等）</p></li>
<li><p>以我目前手上的项目为例，在linkMap中的文件列表，有部分删减，为了方便讲解
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121402.png" alt="展示图片" /></p>

<p>  第一部分(Object files部分)含义：<br/>
  前面中括号表示文件的编号，在后面的部分中会用到,后面表示可执行文件的位置</p>

<p>  第二部分(Sections部分)含义:<br/>
  Address表示偏移位置,Size表示大小,Segment表示段类型(<code>__TEXT</code>,保存程序代码段编译后的机器码，<code>__Data</code>),Section表示段名称(<code>__text</code>表示编译后的程序可执行语句，<code>__data</code>表示已初始化的全局变量和局部静态变量，<code>__bss</code>表示未初始化的全局变量和局部静态变量,<code>__csstring</code>表示代码里的字符串常量)</p>

<p>  可以发现每一行的数据都是紧跟在上一行数据后面， 即第二行到Address为第一行的Address加上第二行的Size组成</p>

<p>  第三部分(symbols部分)含义:
  Address 表示偏移位置,第二部分表示占用大小,第三部分表示所属文件序号，对应上述Object files列表，最后是文件名称</p></li>
<li><p>使用<br/>
 在了解了可执行文件的组成后，我们可以通过计算来获取某个静态库在项目中的占比，通过将.a静态库的.o加起来，就是这个静态库可执行部分占整个app空间的大小。（但是需要注意，此大小并不等于静态库的物理大小，此大小只是可执行文件的大小，要小于静态库的物理大小）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runloop的常见使用]]></title>
    <link href="http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong/"/>
    <updated>2015-12-09T16:32:18+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong</id>
    <content type="html"><![CDATA[<blockquote><p>在之前就做过倒计时的功能，最近封装了一个倒计时的控件，之前一直是用第三方库，没有仔细的去了解原理，最近刚好有时间，就研究了一下NSTimer这个类，在研究的过程中，就发现了，NSTimer需与NSRunLoop结合起来玩的才溜，于是就有了这一篇，在我之前项目中遇到的runloop使用以及结合相关资料的总结;这是第一部分，接下来会在另一篇博客中讲解runloop的原理，以及我对runloop的理解。</p></blockquote>

<!--more-->


<h3>用于“暂停”程序</h3>

<pre><code>- (void)start{
    NSLog(@"start new thread …");
    [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil];
    while (!end) {
        NSLog(@"runloop…");
    ① [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
        NSLog(@"runloop end.");
    }
    NSLog(@"ok.");

}

- (void)runOnNewThread{
    NSLog(@"run for new thread …");
    sleep(1);
    ② [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO];
    NSLog(@"end.");
}

- (void)setEnd{
    end=YES;
}
</code></pre>

<p>调用start方法，输出结果为</p>

<pre><code>2015-12-09 15:42:14.828 Test1[1648:451473] start new thread …
2015-12-09 15:42:14.829 Test1[1648:451473] runloop…
2015-12-09 15:42:14.829 Test1[1648:451585] run for new thread …
2015-12-09 15:42:15.829 Test1[1648:451585] end.
2015-12-09 15:43:00.010 Test1[1648:451473] runloop end.
2015-12-09 15:43:00.010 Test1[1648:451473] ok.
</code></pre>

<p>解释一下为什么要调用②，因为在调用此方法会向主线程发送消息，唤醒runloop，从而及时响应任务；</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码中不难看出，函数的调用顺序，runloop之前的部分 －> newThread部分 －> runloop之后的部分;这样就相当于帮我们形成了一个线程阻塞，但是while循环不受影响，<br/>
<font color=blue size=3>[常见应用场景:]</font>newThread处理网络请求，runloop前后控制是否显示进度菊花</p>

<p></br></p>

<h3>在使用NSTimer的同时使用NSRunloop</h3>

<p>①当使用<a href=#2015120901> scheduledTimerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120902> scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </a>创建NSTimer实例的时候，使用的mode为NSDefaultRunLoopMode</p>

<p>②当使用<a href=#2015120903> timerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120904> timerWithTimeInterval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>③当使用<a href=#2015120906> initWithFireDate:interval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>在某些复杂页面，可能出现NSTimer计时延误的情况，有以下两条思路解决这个问题，1、在子线程中进行NSTimer的操作；2、仍然在主线程中进行NSTimer操作，但是将NSTimer加入到main runloop的特定的mode中；<br/>
</br>
方法1：</p>

<pre><code> if (self.timer) {
     [self.timer invalidate];
     self.timer = nil;
 }
 self.timer = [NSTimer timerWithTimeInterval:0.01 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
</code></pre>

<p>方法2:</p>

<pre><code>创建线程
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
 [thread start];

 //在子线程中做的事情 
-  (void)newThread
 {
     @autoreleasepool
    {
         [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] run];
     }
}
</code></pre>

<p>方法3:</p>

<pre><code>//声明全局变量
 dispatch_source_t _timers;


 uint64_t interval = 0.01 * NSEC_PER_SEC;
 dispatch_queue_t queue = dispatch_queue_create("my queue", 0);
 _timers = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
 dispatch_source_set_timer(_timers, dispatch_time(DISPATCH_TIME_NOW, 0), interval, 0);
  __weak ViewController *blockSelf = self;
 dispatch_source_set_event_handler(_timers, ^()
 {
     NSLog(@"Timer %@", [NSThread currentThread]);
     [blockSelf addTime];
 });
 dispatch_resume(_timers);

- (void)addTime{
    //然后在主线程中修改UI界面：
     dispatch_async(dispatch_get_main_queue(), ^{
             self.label.text = [NSString stringWithFormat:@"%.2f", self.timeCount/100];
     });
 }
</code></pre>

<p><b id=2015120901>+ scheduledTimerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                             invocation:(NSInvocation *)invocation
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120902>+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                                 target:(id)target
                               selector:(SEL)aSelector
                               userInfo:(id)userInfo
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120903>+ timerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120904>+ timerWithTimeInterval:target:selector:userInfo:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                        target:(id)target
                      selector:(SEL)aSelector
                      userInfo:(id)userInfo
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120905>-  addTimer:forMode:</b></p>

<pre><code>- (void)addTimer:(NSTimer *)aTimer
     forMode:(NSString *)mode
</code></pre>

<p><b id=2015120906>- initWithFireDate:interval:target:selector:userInfo:repeats:</b></p>

<pre><code>- (instancetype)initWithFireDate:(NSDate *)date
                    interval:(NSTimeInterval)seconds
                      target:(id)target
                    selector:(SEL)aSelector
                    userInfo:(id)userInfo
                     repeats:(BOOL)repeats
</code></pre>

<p>  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">NSTimer官方参考文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的@dynamic]]></title>
    <link href="http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic/"/>
    <updated>2015-12-07T16:58:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic</id>
    <content type="html"><![CDATA[<blockquote><p>在分析一份代码的时候，遇到了@dynamic，以前也遇到过，但是没有系统的总结一下，刚好有空，系统总结一下，为以后的使用做好准备；</p></blockquote>

<p>一、@dynamic与@synthesize的区别</p>

<ol>
<li>@property有两个对应的词，一个是@synthesize,另一个是@dynamic,当两个都没写的时候，系统会默认为写了@property的属性添加@synthesize var=_var;</li>
<li>@synthesize的语义为如果你没有重写getter或setter方法，系统会自动帮忙生成getter和setter方法，@dynamic的语义为getter和setter方法由用户自己实现，不自动生成；</li>
</ol>


<!--more-->


<p>二、@dynamic的读取<br/>
View.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface View : UIView
{
    NSString * _name;
}

@property (nonatomic,copy) NSString *name;

@end
</code></pre>

<p>View.m</p>

<pre><code>#import "View.h"

@implementation View

@dynamic name;

- (void)setName:(NSString *)name{
   _name = name;
}

- (NSString*)name{
   return _name;
}

@end
</code></pre>

<p>如果没有写setter和getter两个方法，调用的时候，[[View alloc] init].name会报错，但是将@dynamic换成@synthesize的话没有getter和setter也不会有问题；</p>

<p>三、@dynamic的使用</p>

<ol>
<li>用于NSManagedObject中，告诉编译器不要处理属性的getter和setter方法，由CoreData框架来生成getter和setter方法</li>
<li><p>用于分类中,具体使用需要结合到runtime，让分类可以存在属性变量<br/>
例子如下：<br/>
NSObject + AAA.h</p>

<pre><code>  #import &lt;Foundation/Foundation.h&gt;

  @interface NSObject (AAA)
  @property (nonatomic,copy) NSString *aaa;

  @end
</code></pre></li>
</ol>


<p>NSObjct + AAA.m</p>

<pre><code>    #import "NSObject+AAA.h"
    #import &lt;objc/runtime.h&gt;

    static const void *kAAAIdentifier = (void*)@"kAAAIdentifier";

    @implementation NSObject (AAA)

    @dynamic aaa;

    - (void)setAaa:(NSString *)aaa{
            objc_setAssociatedObject(self, kAAAIdentifier, aaa, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }

    - (NSString*)aaa{
        return  objc_getAssociatedObject(self, kAAAIdentifier);
    }

    @end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress部分设置总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie/"/>
    <updated>2015-12-03T17:12:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie</id>
    <content type="html"><![CDATA[<blockquote><p>此文主要用来总结在设置Octopress时遇到的一些需求，但不好找的部分</p></blockquote>

<!--more-->


<p></br></p>

<h3>在首页只显示部分文章内容</h3>

<p><strong>修改原因:</strong>默认情况下，首页会显示每一篇文章的全部，这样给用户的感觉不是很好，首页应该只显示一个对文章的简单介绍，这样既方便了用户查看总体的文件介绍，找到感兴趣的，又不会给用户首页和文章详情是一样的感觉，引导用户点击进入查看全文</p>

<p><strong>设置原理:</strong>在_config.yml里面设置了分隔符<font color=red size=3>excerpt_sepatator</font></p>

<p><strong>设置方法:</strong>将_config.yml里面的<font color=red size=3>excerpt_link</font>字段对应的值中<em>”Continue reading“</em>部分引导用户点击查看全文的文字,并在相应的文章对应的Markdown文档中,找到恰当的地方，加入代码<code>&lt;!--more--&gt;</code></p>

<p><strong>设置以及效果展示</strong>  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120302.png" alt="展示1" />
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120301.png" alt="展示2" /></p>

<p></br></p>

<h3>设置字体、背景色</h3>

<p><strong>修改原因:</strong>可能在撰写markdown文章的时候需要用到文本强调，但markdown常用的语法中并没有提供语法用于改变字体以及背景色</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong></p>

<ol>
<li><font color=red size=2>设置字体</font> 在需要改变属性的文本加上标签<code>&lt;font color=字体颜色 size=字体大小&gt;文本&lt;/font&gt;</code></li>
<li><font color=red size=2>设置背景色</font> 在需要改变背景的文本加上标签<code>&lt;td bgcolor=背景颜色&gt;文本&lt;/td&gt;</code></li>
</ol>


<p><strong>设置Demo</strong></p>

<pre><code>&lt;font color=red size=5&gt;Markdown&lt;/font&gt;
</code></pre>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=red size=5>Markdown</font></p>

<pre><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#ff4500&gt;Markdown&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
或&lt;span style=background-color:#ff4500&gt;Markdown&lt;/span&gt; 
</code></pre>

<table><tr><td bgcolor=#ff4500><font color=white size=2>Markdown</font></td></tr></table>


<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=background-color:#ff4500><font color=white size=2>Markdown</font></span></p>

<p></br></p>

<h3>设置空格</h3>

<p><strong>修改原因:</strong>默认的情况下markdown语法会顶格写，这样不符合一些写作习惯，且在markdown文档中无论敲多少空格，默认只显示一个文本间距，对其实现成难题</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong> 通过<code>&amp;nbsp;</code>来实现字符空格(注意每一个&amp;nbsp相当于一个字符,但中文为两个字符)</p>

<p><strong>设置效果</strong><br/>
<font color=red size=4>Mark&nbsp;&nbsp;Down</font><br/>
<font color=red size=4>你&nbsp;&nbsp;&nbsp;&nbsp;好</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath学习总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/"/>
    <updated>2015-12-03T17:00:10+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css"></p>

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>


<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>




<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>


<div id="category"></div>


<blockquote><p>UIBezierPath对象是CGPathRef数据类型的封装，每一个连接的直线或者去险段的集合称为subpath，一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths，使用UIBezierPath类可以创建机遇矢量的路径，使用此类可以定义简单的形状，如椭圆或者矩形，也可以定义稍微复杂的形状，如多个直线和曲线组成的形状;</p></blockquote>

<!--more-->


<h3>1.UIBezierPath的创建</h3>

<h4>1.1. + bezierPath</h4>

<pre><code>+ (instancetype)bezierPath
返回一个UIBezierPath实例;
</code></pre>

<h4>1.2. + bezierPathWithRect:</h4>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect
传入一个CGRect，构建一个矩形
</code></pre>

<h4>1.3. + bezierPathWithOvalInRect:</h4>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect
传入一个CGRect，构建一个内切椭圆
</code></pre>

<h4>1.4. + bezierPathWithRoundedRect:cornerRadius:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                         cornerRadius:(CGFloat)cornerRadius
创建一个圆角矩形，其中rect为矩形的rect，cornerRadius为圆角率
</code></pre>

<h4>1.5. + bezierPathWithRoundedRect:byRoundingCorners:cornerRadii:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                    byRoundingCorners:(UIRectCorner)corners
                          cornerRadii:(CGSize)cornerRadii
构建一个可指定圆角的矩形,其中rect为矩形的rect，corners为需要圆角的角,cornerRadii为圆角
率(sized的    组成最大不能超过宽高的一半)
</code></pre>

<h4>1.6. + bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center
                             radius:(CGFloat)radius
                         startAngle:(CGFloat)startAngle
                           endAngle:(CGFloat)endAngle
                          clockwise:(BOOL)clockwise
创建一段圆弧,center为圆弧的圆心，radius为半径,startAngle为开始弧度，endAngle为结束弧
度,clockwise为方向  (默认YES为顺时针方向，No为逆时针方向)，具体的开始点与结束点看下方参
考图  
</code></pre>

<p>其中正右顶点为起始点也为结束点,顺时针依次增加;  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120401.png" alt="参考图" /><br/>
<font color=red size=3>[注意]:</font>之所以强调顺时针方向与逆时针防线的原因是，当起始弧度与结束弧度相同的时候，不同的方向画线会得到不同的结果，如0和π/2，顺时针会得到右下部的1/4部分，但逆时针会得到上面的3/4部分;</p>

<h4>1.7. + bezierPathWithCGPath:</h4>

<pre><code>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath
用CGPath创建一个UIBezierPath
</code></pre>

<h4>1.8. - bezierPathByReversingPath</h4>

<pre><code>- (UIBezierPath *)bezierPathByReversingPath
创建一个与原bezierPath路径相同，方向相反的bezierPath对象
</code></pre>

<h3>2. 构建路径</h3>

<h4>2.1. - moveToPoint:</h4>

<pre><code>- (void)moveToPoint:(CGPoint)point
移动起始点到指定位置
</code></pre>

<h4>2.2. - addLineToPoint:</h4>

<pre><code>- (void)addLineToPoint:(CGPoint)point
从起始点增加一条线到指定的point，并在下一次改变时把point当起始点
</code></pre>

<h4>2.3. - addArcWithCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>- (void)addArcWithCenter:(CGPoint)center
              radius:(CGFloat)radius
          startAngle:(CGFloat)startAngle
            endAngle:(CGFloat)endAngle
           clockwise:(BOOL)clockwise
增加一段圆弧，center为圆弧的圆心,radius为圆弧的半径,startAngle为起始圆弧度数,endAngle
为终止圆弧度数,clockwise为是否是顺时钟，与
（+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:）
的演示图中度数的起始点和终止点相同
</code></pre>

<h4>2.4. - addQuadCurveToPoint:controlPoint:</h4>

<pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint
           controlPoint:(CGPoint)controlPoint
新增一段二阶贝塞尔曲线，其中endPoint为结束点，controlPoint为控制点
</code></pre>

<p>二阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120402.png" alt="演示图2" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.5. - addCurveToPoint:controlPoint1:controlPoint2:</h4>

<pre><code>- (void)addCurveToPoint:(CGPoint)endPoint
      controlPoint1:(CGPoint)controlPoint1
      controlPoint2:(CGPoint)controlPoint2
新增一段三阶贝塞尔曲线，其中endPoint结束点，controlPoint1为控制点1,controlPoint2为控制点2
</code></pre>

<p> 三阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120403.png" alt="演示图3" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.6. - closePath</h4>

<pre><code>- (void)closePath
用线段连接最后一个点与最初起始点，使成为一个封闭的形状
</code></pre>

<h4>2.7. - removeAllPoints</h4>

<pre><code>- (void)removeAllPoints
移除所有的点，同时也移除所有的线
</code></pre>

<h4>2.8. - appendPath:</h4>

<pre><code>- (void)appendPath:(UIBezierPath *)bezierPath
将一段路径连接到另外一段路径后面
</code></pre>

<h4>2.9. CGPath <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGPathRef CGPath
主要作用就是获取UIBezierPath的CGPathRef实例，可以用于初始化或者添加到另一个path中。
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
+ bezierPathWithCGPath:  <br/>
- appendPath:</p>

<h4>2.10. cuttrentPoint  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic, readonly) CGPoint currentPoint
主要用于获取当前的坐标点，如果当前路径为空，则当前点的值为坐标原点
</code></pre>

<h3>3. 绘图属性</h3>

<h4>3.1. lineWidth  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGFloat lineWidth
绘图线的宽度,默认为1.0
</code></pre>

<h4>3.2. lineCapStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineCap lineCapStyle
设置起点和终点的样式

enum CGLineCap{
    kCGLineCapButt,
    kCGLineCapRound,
    kCGLineCapSquare 
};
typedef enum CGLineCap CGLineCap;
</code></pre>

<h4>3.3. lineJoinStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineJoin  lineJoinStyle
设置线段连接点的样式

enum CGLineJoin{
    kCGLineJoinMiter,  
    kCGLineJoinRound,
    kCGLineJoinBevel 
}; 
typedef enum CGLineJoin CGLineCap;
</code></pre>

<h4>3.4. usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property (nonatomic) BOOL usesEvenOddFillRule
判断是否使用奇-偶规则绘图, 默认为NO,即采用非零环绕规则绘图
</code></pre>

<p><font color=orange>［名词解释］:</font> 奇－偶规则: 从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。<br/>
非零环绕规则: 首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。左边为奇－偶规则的渲染图，右边为非零环绕规则的渲染图；
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120404.png" alt="演示图4" /></p>

<h4>3.5. - setLineDash:count:phase:</h4>

<pre><code>- (void)setLineDash:(const CGFloat *)pattern
          count:(NSInteger)count
          phase:(CGFloat)phase
画一条虚线,其中pattern为一个C风格的数组，包含段点的长度，count为pattern的数量，phase为
间隔的宽度

例子:    
UIBezierPath *path = [UIBezierPath bezierPath];

path.lineWidth = 5;
path.lineJoinStyle = kCGLineJoinRound;
path.lineCapStyle = kCGLineCapRound;
[path moveToPoint:CGPointMake(100, 100)];
[path addLineToPoint:CGPointMake(200, 100)];

CGFloat a[] = {10};
[path setLineDash:a count:1 phase:5];
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015120406.png" alt="演示图5" /></p>

<h4>3.6 - getLineDash:count:phase:</h4>

<pre><code>- (void)getLineDash:(CGFloat *)pattern
          count:(NSInteger *)count
          phase:(CGFloat *)phase
获取虚线中的属性，pattern为C风格的数组，包含段点的信息,count包含pattern的数量，phase为
间隔的宽度，必须要确保pattern数组足够大，当不知道pattern的长度的时候，可以调用两次该方法，
第一次pattern传NULL，然后根据返回的count值创建数组，再次调用；
</code></pre>

<h4>3.7. - containsPoint:</h4>

<pre><code>- (BOOL)containsPoint:(CGPoint)point
判断点是否在某个封闭区域内，必须是封闭区域，可以调用－ closePath；
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
- closePath:  <br/>
usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></p>

<h3>4. 绘图</h3>

<h4>4.1. - fillWithBlendMode:alpha:</h4>

<pre><code>- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha
填充一个path，blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.2. - strokeWithBlendMode:alpha:</h4>

<pre><code>- (void)strokeWithBlendMode:(CGBlendMode)blendMode
                  alpha:(CGFloat)alpha
以某种方式渲染边界线,blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.3. -fill</h4>

<pre><code>- (void)fill
填充某个路径
</code></pre>

<h4>4.4 - stroke</h4>

<pre><code>- (void)stroke
绘制路径
</code></pre>

<h3>5.动画</h3>

<h4>5.1 - applyTransform:</h4>

<pre><code>- (void)applyTransform:(CGAffineTransform)transform
对路径实现变换，transform变换
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS链式开发(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-%5B%3F%5D/"/>
    <updated>2015-12-02T16:29:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-[?]</id>
    <content type="html"><![CDATA[<blockquote><p>烦不烦？当你需要调用一组动画的时候，需要一个个函数组件的去调用，其实你可以运用你之前学过的block，来实现如一系列的连贯触发行为；</p></blockquote>

<h3>什么是链式开发</h3>

<p>简单的说就是通过“.”操作符调用一系列的操作；</p>

<!--more-->


<h3>链式开发在OC中操作的原理</h3>

<p>原理：结合类属性的getter属性可以通过.调用的特性，我们可以在每一个需要触发的链式环节，定义一个类属性，然后再类属性中返回类的实例，这样，就可以一系列的执行下去；</p>

<p>如:假设有类ChainInvoking;以及属性<code>@property （nonatomic, copy）ChainInvoking* invoking;</code>
则</p>

<pre><code>－ （ChainInvoking* ）invoking{
    /**
        我们想做的事情;
    **/
    return self;
}
</code></pre>

<p>那么此时，self.invoking与self在意义上其实是相等的，不过在self.invoking已经帮我们做了我们想做的事情，一次类推，如果我们有一系列的动作，那么<code>self.invoking1.invoking2...</code>也是可行的，这样就实现了我们的链式调用</p>

<h3>为什么用block而不是直接用类属性</h3>

<ol>
<li>类属性不能传入参数，那么相应的一些功能的时候局限性更大</li>
<li>在最后一个调用的时候，会报警告"Property access result unused-getter should not be used for side effects",意思大概就是获取的getter值，没有实际用途;<br/>
<strong>综上</strong>,最好的办法是使用block 类属性，下面会给大家展示一个例子;</li>
</ol>


<h3>链式操作的实现</h3>

<p>用一个例子说明： <br/>
<strong>ChainedInvoking.h</strong></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface ChainedInvoking : NSObject

@property (nonatomic, copy) ChainedInvoking* (^eat1)();
@property (nonatomic, copy) ChainedInvoking* (^eat)(NSString* );
@property (nonatomic, copy) ChainedInvoking* (^run)();
@property (nonatomic, copy) ChainedInvoking* (^learn)();

@property (nonatomic, copy) ChainedInvoking* play;
@property (nonatomic, copy) ChainedInvoking* sing;
@end
</code></pre>

<p><strong>ChainedInvoking.m</strong></p>

<pre><code>#import "ChainedInvoking.h"

@implementation ChainedInvoking

- (ChainedInvoking* (^)())eat1{  
   return ^{
        NSLog(@"吃饭");
        return self;
  };
}

- (ChainedInvoking* (^)())learn{
    return ^{
     NSLog(@"学习");
        return self;
    };
}   

- (ChainedInvoking* (^)())run{
    return ^{
        NSLog(@"跑步");
        return self;
    };
}

- (ChainedInvoking* (^)(NSString* food))eat{
    return ^(NSString* food){
        NSLog(@"吃---%@",food);
        return self;
    };
}

- (ChainedInvoking*)play{
    NSLog(@"玩耍!");
    return self;
}

- (ChainedInvoking*)sing{
    NSLog(@"唱歌!");
    return self;
}       

@end
</code></pre>

<p><strong>调用:   </strong></p>

<pre><code>ChainedInvoking* invoking = [[ChainedInvoking alloc] init];
invoking.eat1().run().learn().eat(@"辣子鸡饭"); ①
invoking.play.sing.eat(@"红烧牛肉面"); ②
</code></pre>

<p><strong>结果</strong><br/>
①</p>

<pre><code>吃饭
跑步
学习
吃-－－辣子鸡饭
</code></pre>

<p>②</p>

<pre><code>玩耍
唱歌
吃红烧牛肉面
</code></pre>

<h3>参考文档</h3>

<p><a href="http://www.cocoachina.com/ios/20151123/14317.html">使用OC链式调用方式简化SpriteKit的动画调用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用跳转设置]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi/"/>
    <updated>2015-12-02T14:50:56+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi</id>
    <content type="html"><![CDATA[<blockquote><p>经常会在应用中应用中遇到这样的问题，在app内部运行到某个场景的时候，需要打开系统的某项设置，但由于用户的不小心操作，或者当时的一些小想法而在系统弹框的时候选择了拒绝，之后就不能收到某项服务或者在app运行的环节中造成断片，这个时候我们就需要提醒用户手动去去打开系统设置，然后打开相应的服务，这给用户的体验是不好的，最好的用户体验是，如果用户拒绝了某项服务，但当他进入这个应用场景的时候，弹框提示用户的同时，还应该跳转到响应的系统设置页面，进行设置。</p></blockquote>

<!--more-->


<p></br></p>

<h3>跳转本App设置界面以及相应的系统版本</h3>

<p>需要请求一下位置权限或者通知权限，才可以跳进自己的app设置里面，如果没有任何权限请求，就只能跳到系统的设置界面<br/>
<strong>iOS8及以上</strong></p>

<pre><code>        NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
        if([[UIApplication sharedApplication] canOpenURL:url]) {
            NSURL*url =[NSURL URLWithString:UIApplicationOpenSettingsURLString];
            [[UIApplication sharedApplication] openURL:url];
        }
</code></pre>

<p><strong>iOS8以下</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开应用的相册、推送、位置等等信息的时候会跳转到相应的页面</p>

<p></br></p>

<h3>跳转到系统设置</h3>

<p><strong>通用模版</strong></p>

<ol>
<li><p>设置Url Schemes(Target > info > URL Type)<br/>
     <img src="http://7xopon.com1.z0.glb.clouddn.com/8.png" alt="urlSchemes设置" /></p></li>
<li><p>项目相应位置相应的代码<br/>
＃define kCommonMacro  系统设置root</p>

<pre><code>   NSURL *url = [NSURL URLWithString:@"kCommonMacro"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }

  例子:
  **WIFI**
   NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }
</code></pre></li>
</ol>


<p><strong>常用的系统设置prefs</strong></p>

<ul>
<li><p>Notification <pre/>prefs:root=NOTIFICATIONS_ID</p></li>
<li><p>About <pre/>prefs:root=General&amp;path=About</p></li>
<li><p>Accessibility <pre/>prefs:root=General&amp;path=ACCESSIBILITY</p></li>
<li><p>AirplaneModeOn <pre/>prefs:root=AIRPLANE_MODE</p></li>
<li><p>Auto-Lock <pre/>prefs:root=General&amp;path=AUTOLOCK</p></li>
<li><p>Brightness <pre/>prefs:root=Brightness</p></li>
<li><p>Bluetooth <pre/>prefs:root=General&amp;path=Bluetooth</p></li>
<li><p>Date&amp; Time <pre/>prefs:root=General&amp;path=DATE_AND_TIME</p></li>
<li><p>FaceTime <pre/>prefs:root=FACETIME</p></li>
<li><p>General <pre/>prefs:root=General</p></li>
<li><p>Keyboard <pre/>prefs:root=General&amp;path=Keyboard</p></li>
<li><p>iCloud <pre/>prefs:root=CASTLE  iCloud</p></li>
<li><p>Storage &amp; Backup <pre/>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</p></li>
<li><p>International <pre/>prefs:root=General&amp;path=INTERNATIONAL</p></li>
<li><p>Location Services <pre/>prefs:root=LOCATION_SERVICES</p></li>
<li><p>Music <pre/>prefs:root=MUSIC</p></li>
<li><p>Music Equalizer <pre/>prefs:root=MUSIC&amp;path=EQ</p></li>
<li><p>Music VolumeLimit <pre/>prefs:root=MUSIC&amp;path=VolumeLimit</p></li>
<li><p>Network <pre/>prefs:root=General&amp;path=Network</p></li>
<li><p>Nike + iPod <pre/>prefs:root=NIKE_PLUS_IPOD</p></li>
<li><p>Notes <pre/>prefs:root=NOTES</p></li>
<li><p>Phone <pre/>prefs:root=Phone</p></li>
<li><p>Photos <pre/>prefs:root=Photos</p></li>
<li><p>Profile <pre/>prefs:root=General&amp;path=ManagedConfigurationList</p></li>
<li><p>Reset <pre/>prefs:root=General&amp;path=Reset</p></li>
<li><p>Safari <pre/>prefs:root=Safari</p></li>
<li><p>Siri <pre/>prefs:root=General&amp;path=Assistant</p></li>
<li><p>Sounds <pre/>prefs:root=Sounds</p></li>
<li><p>SoftwareUpdate <pre/>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</p></li>
<li><p>Store <pre/>prefs:root=STORE</p></li>
<li><p>Twitter <pre/>prefs:root=TWITTER</p></li>
<li><p>Usage <pre/>prefs:root=General&amp;path=USAGE</p></li>
<li><p>VPN <pre/>prefs:root=General&amp;path=Network/VPN</p></li>
<li><p>Wallpaper <pre/>prefs:root=Wallpaper</p></li>
<li><p>Wi-Fi <pre/>prefs:root=WIFI</p></li>
<li><p>Setting  <pre/>prefs:root=INTERNET_TETHERING</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法学习]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi/"/>
    <updated>2015-12-02T14:05:11+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi</id>
    <content type="html"><![CDATA[<blockquote><p>基于一些巧合的原因接触了Octopress制作个人博客，在基本上搞定了所有基础框架的基础上，开始创建第一篇博客，但是发现，主体文章是基于Markdown的文档，之前基本上没有任何了解，搜集各种资料以及各个大神的博客，初步了解了一些基础语法，总结如下，希望能给以后的自己或你们提供力所能及的帮助;</p></blockquote>

<!--more-->


<h3>学习工具</h3>

<p>推荐使用Mou,<a href="http://25.io/mou/">下载地址</a></p>

<h3>学习历程:</h3>

<ul>
<li>了解最基本的语法</li>
<li>尝试把所有的语法运用到一个简单的Demo中</li>
</ul>


<h3>基本语法</h3>

<p>大致分为4个部分：文本、列表、样式、图片链接</p>

<h4>文本</h4>

<ul>
<li>文字粗体 语法为: <strong>变粗的文本</strong></li>
<li>文本斜体 语法为: <em>斜体部分</em></li>
<li>下标     语法为: someText[^flag] [^flag]:des<br/>
<strong>需要特别注意</strong> 下标语法中标记与解释不能放在一行中完成     <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/3.png" alt="图片效果" /></li>
</ul>


<h4>列表</h4>

<ul>
<li>有序列表  语法: 阿拉伯数字+.  如1.</li>
<li>无序列表  语法: -或*+需要序列化的字符串,如基本语法样式</li>
<li>列表＋代码  语法: 首先换行，删掉头部的自动添加的列表符号，然后连续两个Tab或者8个空格 <br/>
<strong>需要特别注意</strong> 无论是有序还是无序，系统只会保持一种风格，且符号与文本之间必须隔着一个空格
 <img src="http://7xopon.com1.z0.glb.clouddn.com/5.png" alt="图片效果" /></li>
</ul>


<h4>样式</h4>

<ul>
<li>一级标题 语法为: #Markdown</li>
<li>二级标题 语法为: ##Markdown</li>
<li>三级标题 语法为: ###Markdown</li>
<li>引导语   语法为:> + 空格 +文本 如> 你好</li>
<li>段落分隔线 语法为: &mdash; 或者  ***</li>
<li>简单文字代码框   语法为: <code>代码段</code></li>
<li>段落代码框      语法为:Tab/4个空格+代码段（需要注意Tab前面不能存在含有意义的*,如果存在可用分割线来分隔)</li>
<li><p>表格     语法为:</p>

<pre><code>| 列名        | 列名          | 列名  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre>

<p><strong>需要特别注意</strong>本区块的代码必须要独立一行书写，且引导语标志必须➕空格
<img src="http://7xopon.com1.z0.glb.clouddn.com/6.png" alt="图片效果" /></p></li>
</ul>


<h4>图片与链接</h4>

<ul>
<li>   链接    语法为: <a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名</a> 如<a href="www.baidu.com">百度</a></li>
<li>   图片    语法为<img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="图片名" />
如<img src="http://7xopon.com1.z0.glb.clouddn.com/1.jpg" alt="Mou icon" /></li>
</ul>


<h3>Demo范文</h3>

<p>本文Markdown源码：有兴趣的可以试着敲一遍!
<img src="http://7xopon.com1.z0.glb.clouddn.com/7.png" alt="Demo范文" /></p>
]]></content>
  </entry>
  
</feed>
