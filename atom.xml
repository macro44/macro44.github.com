<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2015-12-04T16:40:32+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Octopress部分设置总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie/"/>
    <updated>2015-12-03T17:12:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie</id>
    <content type="html"><![CDATA[<blockquote><p>此文主要用来总结在设置Octopress时遇到的一些需求，但不好找的部分</p></blockquote>

<!--more-->


<p></br></p>

<h3>在首页只显示部分文章内容</h3>

<p><strong>修改原因:</strong>默认情况下，首页会显示每一篇文章的全部，这样给用户的感觉不是很好，首页应该只显示一个对文章的简单介绍，这样既方便了用户查看总体的文件介绍，找到感兴趣的，又不会给用户首页和文章详情是一样的感觉，引导用户点击进入查看全文</p>

<p><strong>设置原理:</strong>在_config.yml里面设置了分隔符<font color=red size=3>excerpt_sepatator</font></p>

<p><strong>设置方法:</strong>将_config.yml里面的<font color=red size=3>excerpt_link</font>字段对应的值中<em>”Continue reading“</em>部分引导用户点击查看全文的文字,并在相应的文章对应的Markdown文档中,找到恰当的地方，加入代码<code>&lt;!--more--&gt;</code></p>

<p><strong>设置以及效果展示</strong>  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120302.png" alt="展示1" />
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120301.png" alt="展示2" /></p>

<p></br></p>

<h3>设置字体、背景色</h3>

<p><strong>修改原因:</strong>可能在撰写markdown文章的时候需要用到文本强调，但markdown常用的语法中并没有提供语法用于改变字体以及背景色</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong></p>

<ol>
<li><font color=red size=2>设置字体</font> 在需要改变属性的文本加上标签<code>&lt;font color=字体颜色 size=字体大小&gt;文本&lt;/font&gt;</code></li>
<li><font color=red size=2>设置背景色</font> 在需要改变背景的文本加上标签<code>&lt;td bgcolor=背景颜色&gt;文本&lt;/td&gt;</code></li>
</ol>


<p><strong>设置Demo</strong></p>

<pre><code>&lt;font color=red size=5&gt;Markdown&lt;/font&gt;
</code></pre>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=red size=5>Markdown</font></p>

<pre><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#ff4500&gt;Markdown&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
或&lt;span style=background-color:#ff4500&gt;Markdown&lt;/span&gt; 
</code></pre>

<table><tr><td bgcolor=#ff4500><font color=white size=2>Markdown</font></td></tr></table>


<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=background-color:#ff4500><font color=white size=2>Markdown</font></span></p>

<p></br></p>

<h3>设置空格</h3>

<p><strong>修改原因:</strong>默认的情况下markdown语法会顶格写，这样不符合一些写作习惯，且在markdown文档中无论敲多少空格，默认只显示一个文本间距，对其实现成难题</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong> 通过<code>&amp;nbsp;</code>来实现字符空格(注意每一个&amp;nbsp相当于一个字符,但中文为两个字符)</p>

<p><strong>设置效果</strong><br/>
<font color=red size=4>Mark&nbsp;&nbsp;Down</font><br/>
<font color=red size=4>你&nbsp;&nbsp;&nbsp;&nbsp;好</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath学习总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/"/>
    <updated>2015-12-03T17:00:10+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css"></p>

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>


<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>




<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>


<div id="category"></div>


<blockquote><p>UIBezierPath对象是CGPathRef数据类型的封装，每一个连接的直线或者去险段的集合称为subpath，一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths，使用UIBezierPath类可以创建机遇矢量的路径，使用此类可以定义简单的形状，如椭圆或者矩形，也可以定义稍微复杂的形状，如多个直线和曲线组成的形状;</p></blockquote>

<h3>1.UIBezierPath的创建</h3>

<h4>1.1. + bezierPath</h4>

<pre><code>+ (instancetype)bezierPath
返回一个UIBezierPath实例;
</code></pre>

<h4>1.2. + bezierPathWithRect:</h4>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect
传入一个CGRect，构建一个矩形
</code></pre>

<h4>1.3. + bezierPathWithOvalInRect:</h4>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect
传入一个CGRect，构建一个内切椭圆
</code></pre>

<h4>1.4. + bezierPathWithRoundedRect:cornerRadius:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                         cornerRadius:(CGFloat)cornerRadius
创建一个圆角矩形，其中rect为矩形的rect，cornerRadius为圆角率
</code></pre>

<h4>1.5. + bezierPathWithRoundedRect:byRoundingCorners:cornerRadii:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                    byRoundingCorners:(UIRectCorner)corners
                          cornerRadii:(CGSize)cornerRadii
构建一个可指定圆角的矩形,其中rect为矩形的rect，corners为需要圆角的角,cornerRadii为圆角
率(sized的    组成最大不能超过宽高的一半)
</code></pre>

<h4>1.6. + bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center
                             radius:(CGFloat)radius
                         startAngle:(CGFloat)startAngle
                           endAngle:(CGFloat)endAngle
                          clockwise:(BOOL)clockwise
创建一段圆弧,center为圆弧的圆心，radius为半径,startAngle为开始弧度，endAngle为结束弧度,clockwise为方向    (默认YES为顺时针方向，No为逆时针方向)，具体的开始点与结束点看下方参考图 
</code></pre>

<p>其中正右顶点为起始点也为结束点,顺时针依次增加;  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120401.png" alt="参考图" /><br/>
<font color=red size=3>[注意]:</font>之所以强调顺时针方向与逆时针防线的原因是，当起始弧度与结束弧度相同的时候，不同的方向画线会得到不同的结果，如0和π/2，顺时针会得到右下部的1/4部分，但逆时针会得到上面的3/4部分;</p>

<h4>1.7. + bezierPathWithCGPath:</h4>

<pre><code>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath
用CGPath创建一个UIBezierPath
</code></pre>

<h4>1.8. - bezierPathByReversingPath</h4>

<pre><code>- (UIBezierPath *)bezierPathByReversingPath
创建一个与原bezierPath路径相同，方向相反的bezierPath对象
</code></pre>

<h3>2. 构建路径</h3>

<h4>2.1. - moveToPoint:</h4>

<pre><code>- (void)moveToPoint:(CGPoint)point
移动起始点到指定位置
</code></pre>

<h4>2.2. - addLineToPoint:</h4>

<pre><code>- (void)addLineToPoint:(CGPoint)point
从起始点增加一条线到指定的point，并在下一次改变时把point当起始点
</code></pre>

<h4>2.3. - addArcWithCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>- (void)addArcWithCenter:(CGPoint)center
              radius:(CGFloat)radius
          startAngle:(CGFloat)startAngle
            endAngle:(CGFloat)endAngle
           clockwise:(BOOL)clockwise
增加一段圆弧，center为圆弧的圆心,radius为圆弧的半径,startAngle为起始圆弧度数,endAngle为终止圆弧度数,
clockwise为是否是顺时钟，与（+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:）
的演示图中度数的起始点和终止点相同
</code></pre>

<h4>2.4. - addQuadCurveToPoint:controlPoint:</h4>

<pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint
           controlPoint:(CGPoint)controlPoint
新增一段二阶贝塞尔曲线，其中endPoint为结束点，controlPoint为控制点
</code></pre>

<p>二阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120402.png" alt="演示图2" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.5. - addCurveToPoint:controlPoint1:controlPoint2:</h4>

<pre><code>- (void)addCurveToPoint:(CGPoint)endPoint
      controlPoint1:(CGPoint)controlPoint1
      controlPoint2:(CGPoint)controlPoint2
新增一段三阶贝塞尔曲线，其中endPoint结束点，controlPoint1为控制点1,controlPoint2为控制点2
</code></pre>

<p> 三阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120403.png" alt="演示图3" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.6. - closePath</h4>

<pre><code>- (void)closePath
用线段连接最后一个点与最初起始点，使成为一个封闭的形状
</code></pre>

<h4>2.7. - removeAllPoints</h4>

<pre><code>- (void)removeAllPoints
移除所有的点，同时也移除所有的线
</code></pre>

<h4>2.8. - appendPath:</h4>

<pre><code>- (void)appendPath:(UIBezierPath *)bezierPath
将一段路径连接到另外一段路径后面
</code></pre>

<h4>2.9. CGPath <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGPathRef CGPath
主要作用就是获取UIBezierPath的CGPathRef实例，可以用于初始化或者添加到另一个path中。
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
+ bezierPathWithCGPath:  <br/>
- appendPath:</p>

<h4>2.10. cuttrentPoint  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic, readonly) CGPoint currentPoint
主要用于获取当前的坐标点，如果当前路径为空，则当前点的值为坐标原点
</code></pre>

<h3>3. 绘图属性</h3>

<h4>3.1. lineWidth  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGFloat lineWidth
绘图线的宽度,默认为1.0
</code></pre>

<h4>3.2. lineCapStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineCap lineCapStyle
设置起点和终点的样式

enum CGLineCap{
    kCGLineCapButt,
    kCGLineCapRound,
    kCGLineCapSquare 
};
typedef enum CGLineCap CGLineCap;
</code></pre>

<h4>3.3. lineJoinStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineJoin  lineJoinStyle
设置线段连接点的样式

enum CGLineJoin{
    kCGLineJoinMiter,  
    kCGLineJoinRound,
    kCGLineJoinBevel 
}; 
typedef enum CGLineJoin CGLineCap;
</code></pre>

<h4>3.4. usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property (nonatomic) BOOL usesEvenOddFillRule
判断是否使用奇-偶规则绘图, 默认为NO,即采用非零环绕规则绘图
</code></pre>

<p><font color=orange>［名词解释］:</font> 奇－偶规则: 从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。<br/>
非零环绕规则: 首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。左边为奇－偶规则的渲染图，右边为非零环绕规则的渲染图；
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120404.png" alt="演示图4" /></p>

<h4>3.5. - setLineDash:count:phase:</h4>

<pre><code>- (void)setLineDash:(const CGFloat *)pattern
          count:(NSInteger)count
          phase:(CGFloat)phase
画一条虚线,其中pattern为一个C风格的数组，包含段点的长度，count为pattern的数量，phase为间隔的宽度

例子:    
UIBezierPath *path = [UIBezierPath bezierPath];

path.lineWidth = 5;
path.lineJoinStyle = kCGLineJoinRound;
path.lineCapStyle = kCGLineCapRound;
[path moveToPoint:CGPointMake(100, 100)];
[path addLineToPoint:CGPointMake(200, 100)];

CGFloat a[] = {10};
[path setLineDash:a count:1 phase:5];
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015120406.png" alt="演示图5" /></p>

<h3>3.6 - getLineDash:count:phase:</h3>

<pre><code>- (void)getLineDash:(CGFloat *)pattern
          count:(NSInteger *)count
          phase:(CGFloat *)phase
获取虚线中的某一段
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS链式开发(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-%5B%3F%5D/"/>
    <updated>2015-12-02T16:29:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-[?]</id>
    <content type="html"><![CDATA[<blockquote><p>烦不烦？当你需要调用一组动画的时候，需要一个个函数组件的去调用，其实你可以运用你之前学过的block，来实现如一系列的连贯触发行为；</p></blockquote>

<h3>什么是链式开发</h3>

<p>简单的说就是通过“.”操作符调用一系列的操作；</p>

<!--more-->


<h3>链式开发在OC中操作的原理</h3>

<p>原理：结合类属性的getter属性可以通过.调用的特性，我们可以在每一个需要触发的链式环节，定义一个类属性，然后再类属性中返回类的实例，这样，就可以一系列的执行下去；</p>

<p>如:假设有类ChainInvoking;以及属性<code>@property （nonatomic, copy）ChainInvoking* invoking;</code>
则</p>

<pre><code>－ （ChainInvoking* ）invoking{
    /**
        我们想做的事情;
    **/
    return self;
}
</code></pre>

<p>那么此时，self.invoking与self在意义上其实是相等的，不过在self.invoking已经帮我们做了我们想做的事情，一次类推，如果我们有一系列的动作，那么<code>self.invoking1.invoking2...</code>也是可行的，这样就实现了我们的链式调用</p>

<h3>为什么用block而不是直接用类属性</h3>

<ol>
<li>类属性不能传入参数，那么相应的一些功能的时候局限性更大</li>
<li>在最后一个调用的时候，会报警告"Property access result unused-getter should not be used for side effects",意思大概就是获取的getter值，没有实际用途;<br/>
<strong>综上</strong>,最好的办法是使用block 类属性，下面会给大家展示一个例子;</li>
</ol>


<h3>链式操作的实现</h3>

<p>用一个例子说明： <br/>
<strong>ChainedInvoking.h</strong></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface ChainedInvoking : NSObject

@property (nonatomic, copy) ChainedInvoking* (^eat1)();
@property (nonatomic, copy) ChainedInvoking* (^eat)(NSString* );
@property (nonatomic, copy) ChainedInvoking* (^run)();
@property (nonatomic, copy) ChainedInvoking* (^learn)();

@property (nonatomic, copy) ChainedInvoking* play;
@property (nonatomic, copy) ChainedInvoking* sing;
@end
</code></pre>

<p><strong>ChainedInvoking.m</strong></p>

<pre><code>#import "ChainedInvoking.h"

@implementation ChainedInvoking

- (ChainedInvoking* (^)())eat1{  
   return ^{
        NSLog(@"吃饭");
        return self;
  };
}

- (ChainedInvoking* (^)())learn{
    return ^{
     NSLog(@"学习");
        return self;
    };
}   

- (ChainedInvoking* (^)())run{
    return ^{
        NSLog(@"跑步");
        return self;
    };
}

- (ChainedInvoking* (^)(NSString* food))eat{
    return ^(NSString* food){
        NSLog(@"吃---%@",food);
        return self;
    };
}

- (ChainedInvoking*)play{
    NSLog(@"玩耍!");
    return self;
}

- (ChainedInvoking*)sing{
    NSLog(@"唱歌!");
    return self;
}       

@end
</code></pre>

<p><strong>调用:   </strong></p>

<pre><code>ChainedInvoking* invoking = [[ChainedInvoking alloc] init];
invoking.eat1().run().learn().eat(@"辣子鸡饭"); ①
invoking.play.sing.eat(@"红烧牛肉面"); ②
</code></pre>

<p><strong>结果</strong><br/>
①</p>

<pre><code>吃饭
跑步
学习
吃-－－辣子鸡饭
</code></pre>

<p>②</p>

<pre><code>玩耍
唱歌
吃红烧牛肉面
</code></pre>

<h3>参考文档</h3>

<p><a href="http://www.cocoachina.com/ios/20151123/14317.html">使用OC链式调用方式简化SpriteKit的动画调用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用跳转设置]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi/"/>
    <updated>2015-12-02T14:50:56+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi</id>
    <content type="html"><![CDATA[<blockquote><p>经常会在应用中应用中遇到这样的问题，在app内部运行到某个场景的时候，需要打开系统的某项设置，但由于用户的不小心操作，或者当时的一些小想法而在系统弹框的时候选择了拒绝，之后就不能收到某项服务或者在app运行的环节中造成断片，这个时候我们就需要提醒用户手动去去打开系统设置，然后打开相应的服务，这给用户的体验是不好的，最好的用户体验是，如果用户拒绝了某项服务，但当他进入这个应用场景的时候，弹框提示用户的同时，还应该跳转到响应的系统设置页面，进行设置。</p></blockquote>

<!--more-->


<p></br></p>

<h3>跳转本App设置界面以及相应的系统版本</h3>

<p>需要请求一下位置权限或者通知权限，才可以跳进自己的app设置里面，如果没有任何权限请求，就只能跳到系统的设置界面<br/>
<strong>iOS8及以上</strong></p>

<pre><code>        NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
        if([[UIApplication sharedApplication] canOpenURL:url]) {
            NSURL*url =[NSURL URLWithString:UIApplicationOpenSettingsURLString];
            [[UIApplication sharedApplication] openURL:url];
        }
</code></pre>

<p><strong>iOS8以下</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开应用的相册、推送、位置等等信息的时候会跳转到相应的页面</p>

<p></br></p>

<h3>跳转到系统设置</h3>

<p><strong>通用模版</strong></p>

<ol>
<li><p>设置Url Schemes(Target > info > URL Type)<br/>
     <img src="http://7xopon.com1.z0.glb.clouddn.com/8.png" alt="urlSchemes设置" /></p></li>
<li><p>项目相应位置相应的代码<br/>
＃define kCommonMacro  系统设置root</p>

<pre><code>   NSURL *url = [NSURL URLWithString:@"kCommonMacro"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }

  例子:
  **WIFI**
   NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }
</code></pre></li>
</ol>


<p><strong>常用的系统设置prefs</strong></p>

<ul>
<li><p>Notification <pre/>prefs:root=NOTIFICATIONS_ID</p></li>
<li><p>About <pre/>prefs:root=General&amp;path=About</p></li>
<li><p>Accessibility <pre/>prefs:root=General&amp;path=ACCESSIBILITY</p></li>
<li><p>AirplaneModeOn <pre/>prefs:root=AIRPLANE_MODE</p></li>
<li><p>Auto-Lock <pre/>prefs:root=General&amp;path=AUTOLOCK</p></li>
<li><p>Brightness <pre/>prefs:root=Brightness</p></li>
<li><p>Bluetooth <pre/>prefs:root=General&amp;path=Bluetooth</p></li>
<li><p>Date&amp; Time <pre/>prefs:root=General&amp;path=DATE_AND_TIME</p></li>
<li><p>FaceTime <pre/>prefs:root=FACETIME</p></li>
<li><p>General <pre/>prefs:root=General</p></li>
<li><p>Keyboard <pre/>prefs:root=General&amp;path=Keyboard</p></li>
<li><p>iCloud <pre/>prefs:root=CASTLE  iCloud</p></li>
<li><p>Storage &amp; Backup <pre/>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</p></li>
<li><p>International <pre/>prefs:root=General&amp;path=INTERNATIONAL</p></li>
<li><p>Location Services <pre/>prefs:root=LOCATION_SERVICES</p></li>
<li><p>Music <pre/>prefs:root=MUSIC</p></li>
<li><p>Music Equalizer <pre/>prefs:root=MUSIC&amp;path=EQ</p></li>
<li><p>Music VolumeLimit <pre/>prefs:root=MUSIC&amp;path=VolumeLimit</p></li>
<li><p>Network <pre/>prefs:root=General&amp;path=Network</p></li>
<li><p>Nike + iPod <pre/>prefs:root=NIKE_PLUS_IPOD</p></li>
<li><p>Notes <pre/>prefs:root=NOTES</p></li>
<li><p>Phone <pre/>prefs:root=Phone</p></li>
<li><p>Photos <pre/>prefs:root=Photos</p></li>
<li><p>Profile <pre/>prefs:root=General&amp;path=ManagedConfigurationList</p></li>
<li><p>Reset <pre/>prefs:root=General&amp;path=Reset</p></li>
<li><p>Safari <pre/>prefs:root=Safari</p></li>
<li><p>Siri <pre/>prefs:root=General&amp;path=Assistant</p></li>
<li><p>Sounds <pre/>prefs:root=Sounds</p></li>
<li><p>SoftwareUpdate <pre/>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</p></li>
<li><p>Store <pre/>prefs:root=STORE</p></li>
<li><p>Twitter <pre/>prefs:root=TWITTER</p></li>
<li><p>Usage <pre/>prefs:root=General&amp;path=USAGE</p></li>
<li><p>VPN <pre/>prefs:root=General&amp;path=Network/VPN</p></li>
<li><p>Wallpaper <pre/>prefs:root=Wallpaper</p></li>
<li><p>Wi-Fi <pre/>prefs:root=WIFI</p></li>
<li><p>Setting  <pre/>prefs:root=INTERNET_TETHERING</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法学习]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi/"/>
    <updated>2015-12-02T14:05:11+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi</id>
    <content type="html"><![CDATA[<blockquote><p>基于一些巧合的原因接触了Octopress制作个人博客，在基本上搞定了所有基础框架的基础上，开始创建第一篇博客，但是发现，主体文章是基于Markdown的文档，之前基本上没有任何了解，搜集各种资料以及各个大神的博客，初步了解了一些基础语法，总结如下，希望能给以后的自己或你们提供力所能及的帮助;</p></blockquote>

<!--more-->


<h3>学习工具</h3>

<p>推荐使用Mou,<a href="http://25.io/mou/">下载地址</a></p>

<h3>学习历程:</h3>

<ul>
<li>了解最基本的语法</li>
<li>尝试把所有的语法运用到一个简单的Demo中</li>
</ul>


<h3>基本语法</h3>

<p>大致分为4个部分：文本、列表、样式、图片链接</p>

<h4>文本</h4>

<ul>
<li>文字粗体 语法为: <strong>变粗的文本</strong></li>
<li>文本斜体 语法为: <em>斜体部分</em></li>
<li>下标     语法为: someText[^flag] [^flag]:des<br/>
<strong>需要特别注意</strong> 下标语法中标记与解释不能放在一行中完成     <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/3.png" alt="图片效果" /></li>
</ul>


<h4>列表</h4>

<ul>
<li>有序列表  语法: 阿拉伯数字+.  如1.</li>
<li>无序列表  语法: -或*+需要序列化的字符串,如基本语法样式</li>
<li>列表＋代码  语法: 首先换行，删掉头部的自动添加的列表符号，然后连续两个Tab或者8个空格 <br/>
<strong>需要特别注意</strong> 无论是有序还是无序，系统只会保持一种风格，且符号与文本之间必须隔着一个空格
 <img src="http://7xopon.com1.z0.glb.clouddn.com/5.png" alt="图片效果" /></li>
</ul>


<h4>样式</h4>

<ul>
<li>一级标题 语法为: #Markdown</li>
<li>二级标题 语法为: ##Markdown</li>
<li>三级标题 语法为: ###Markdown</li>
<li>引导语   语法为:> + 空格 +文本 如> 你好</li>
<li>段落分隔线 语法为: &mdash; 或者  ***</li>
<li>简单文字代码框   语法为: <code>代码段</code></li>
<li>段落代码框      语法为:Tab/4个空格+代码段（需要注意Tab前面不能存在含有意义的*,如果存在可用分割线来分隔)</li>
<li><p>表格     语法为:</p>

<pre><code>| 列名        | 列名          | 列名  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre>

<p><strong>需要特别注意</strong>本区块的代码必须要独立一行书写，且引导语标志必须➕空格
<img src="http://7xopon.com1.z0.glb.clouddn.com/6.png" alt="图片效果" /></p></li>
</ul>


<h4>图片与链接</h4>

<ul>
<li>   链接    语法为: <a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名</a> 如<a href="www.baidu.com">百度</a></li>
<li>   图片    语法为<img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="图片名" />
如<img src="http://7xopon.com1.z0.glb.clouddn.com/1.jpg" alt="Mou icon" /></li>
</ul>


<h3>Demo范文</h3>

<p>本文Markdown源码：有兴趣的可以试着敲一遍!
<img src="http://7xopon.com1.z0.glb.clouddn.com/7.png" alt="Demo范文" /></p>
]]></content>
  </entry>
  
</feed>
