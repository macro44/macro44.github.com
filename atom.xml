<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[谁在弹一曲东风破]]></title>
  <link href="http://macro44.github.io/atom.xml" rel="self"/>
  <link href="http://macro44.github.io/"/>
  <updated>2015-12-21T18:42:58+08:00</updated>
  <id>http://macro44.github.io/</id>
  <author>
    <name><![CDATA[Macro]]></name>
    <email><![CDATA[macro_zj@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sqlite系统化学习之基础语法]]></title>
    <link href="http://macro44.github.io/blog/2015/12/21/sqlitexi-tong-hua-xue-xi-zhi-ji-chu-yu-fa/"/>
    <updated>2015-12-21T15:07:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/21/sqlitexi-tong-hua-xue-xi-zhi-ji-chu-yu-fa</id>
    <content type="html"><![CDATA[<blockquote><p>之前在项目中使用sqlite的时候，都是使用现成的基本框架，没有具体细致的去了解sqlite的从无到有的使用，最近有时间看一下sqlite语法，分为两个部分来总结一下sqlite的语法，第一部分主要用来写一些sqlite语法。主要分为两篇，这是之一，基础语法篇，还有一篇高级语法篇。第二部分用来分析在iOS项目中sqlite框架的构成，以及基本使用。</p></blockquote>

<!--more-->


<p>本教程目录：</p>

<script>
function alertWarming(){
    alert("因为本部分在iOS上用不上，所以忽略！");
}
function backToMenu(){
    window.scrollTo(0,100);
}

</script>




<dl>
    <dt><a href=#1.1>1. SQLite数据类型</a></dt>
        <dd><a href=#1.1>1.1 SQLite存储类</a><br/>    
            <a href=#1.2>1.2 Boolean数据类型</a><br/>
            <a href=#1.3>1.3 Date与Time数据类型</a><br/>
            <a href=#1.4>1.4 SQLite 亲和(Affinity)类型</a>
        </dd>
    <dt><a href=#2.1 onclick="alertWarming()">2. SQLite数据库</a><br/></dt>
        <dd><a href=#2.1 onclick="alertWarming()">2.1 SQLite创建数据库</a><br/>
            <a href=#2.2 onclick="alertWarming()">2.2 SQLite关联数据库</a><br/>
            <a href=#2.3 onclick="alertWarming()">2.3 SQLite分离数据库</a>
        </dd>
        
    <dt><a href=#3.1>3. SQLite 表</a><br/></dt>
        <dd><a href=#3.1>3.1 SQLite创建表</a></br>
            <a href=#3.2>3.2 SQLite删除表</a>
        </dd>
        
    <dt><a href=#4.1>4. SQLite 运算符</a></dt>
        <dd><a href=#4.1>4.1 算数运算符</a><br/>
            <a href=#4.2>4.2 比较运算符</a><br/>
            <a href=#4.3>4.3 逻辑运算符</a><br/>
            <a href=#4.4>4.4 位运算符</a>
        </dd>
    
    </dt>   
        
    <dt><a href=#6.1>6. SQL基本操作</a><br/></dt>
        <dd><a href=#6.1>6.1 SQL Insert语句</a><br/>
            <a href=#6.2>6.2 SQL Delete语句</a><br/>
            <a href=#6.3>6.3 SQL Update语句</a><br/>
            <a href=#6.4>6.4 SQL Select语句</a>
        </dd>
</dl>


<p><a id=1.1>1.1 SQLite存储类</a></p>

<table>
<thead>
<tr>
<th> 存储类 </th>
<th> 描述        </th>
</tr>
</thead>
<tbody>
<tr>
<td> NULL  </td>
<td>值是一个NULL值.</td>
</tr>
<tr>
<td> INTEGER </td>
<td> 值是一个带符号的整形，根据值的大小存储在1、2、3、4、6、8字节中</td>
</tr>
<tr>
<td>REAL</td>
<td> 值是一个浮点值,存储为8字节点的IEE浮点数字</td>
</tr>
<tr>
<td>TEXT</td>
<td>值是一个文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>用于存储blob数据段，如图片、语音、视频等</td>
</tr>
</tbody>
</table>


<p><a id=1.2>1.2 Boolean数据类型</a><br/>
    Sqlite没有单独的Boolean存储类,布尔值被存储为整数0和1</p>

<p><a id=1.3>1.3 Date与Time数据类型</a><br/>
SQLite没有单独的用语存储日期或时间的存储类，但是SQLite能够把日期和时间存储为TEXT、REAL或INTEGER值.</p>

<table>
<thead>
<tr>
<th>存储类</th>
<th>日期格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>TEXT</td>
<td>格式为"YYYY-MM-DD HH:MM:SS.SSS"的日期</td>
</tr>
<tr>
<td>REAL</td>
<td>从公元前4714年11月24日格林尼治的正午开始算起的天数</td>
</tr>
<tr>
<td>INTEGER</td>
<td>从1970-01－01 00:00:00 UTC算起的秒数.</td>
</tr>
</tbody>
</table>


<p><a id=1.4>1.4 SQLite 亲和(Affinity)类型</a></p>

<table border='1' cellspacing="0" style="text-align:center">
<tr>
    <th>Affinity</th>
    <th>描述</th>
</tr>
<tr>
    <td>TEXT</td>
    <td>该列使用存储类NULL、TEXT或BLOB存储所有数据</td>
</tr>
<tr>
    <td>NUMERIC</td>
    <td>该列可以包含使用所有五个存储类的值。</td>
</tr>
<tr>
    <td>INTEGER</td>
    <td>与带有 NUMERIC affinity 的列相同，在 CAST 表达式中带有异常。</td>
</tr>
<tr>
    <td>REAL</td>
    <td>与带有 NUMERIC affinity 的列相似，不同的是，它会强制把整数值转换为浮点表示。</td>
</tr>
<tr>
    <td>NONE</td>
    <td>    带有 affinity NONE 的列，不会优先使用哪个存储类，也不会尝试把数据从一个存储类强制转换为另一个存储类。</td>
</tr>
</table>


<p>Affinity类型每一种包含的具体类型参照表:</p>

<div align="center">
<table border='1' cellspacing="0" style="text-align:center">
<tr>
    <th>数据类型</th>
    <th>Affinity</th>
<tr>
<tr>
    <td>
        <ul>
            <li>INT</li>
            <li>INTEGER</li>
            <li>TINYINT</li>
            <li>SMALLINT</li>
            <li>MEDIUMINT</li>
            <li>BIGINT</li>
            <li>UNSIGNED BIG INT</li>
            <li>INT2</li>
            <li>INT8</li>
        </ul>
    </td>
    <td>INTEGER</td>
</tr>
<tr>
    <td>
        <ul>
            <li>CHARACTER(20)</li>
            <li>VARCHAR(255)</li>
            <li>VARYING CHARACTER(255)</li>
            <li>NCHAR(55)</li>
            <li>NATIVE CHARACTER(70)</li>
            <li>NVARCHAR(100)</li>
            <li>TEXT</li>
            <li>CLOB</li>
         </ul>
    </td>
    <td>TEXT</td>
</tr>
<tr>
    <td>
        <ul>
            <li>BLOB</li>
            <li>no datatype specified</li>
        </ul>
    </td>
    <td>NONE</td>
</tr>
<tr>
    <td>
        <ul>
            <li>REAL</li>
            <li>DOUBLE</li>
            <li>DOUBLE PRECISION</li>
            <li>FLOAT</li>
        </ul>
    </td>
    <td>REAL</td>
</tr>
<tr>
    <td>
        <ul>
            <li>NUMERIC</li>
            <li>DECIMAL(10,5)</li>
            <li>BOOLEAN</li>
            <li>DATE</li>
            <li>DATETIME</li>
        </ul>
    </td>
    <td>NUMERIC</td>
</tr>
</table>
</div>


<p><br/>
<a id=2.1>2.1 SQLite创建数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=2.2>2.2 SQLite关联数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=2.3>2.3 SQLite分离数据库</a><br/>
<strong>因为本部分在iOS上用不上，所以忽略！</strong>
<input type="button" value="返回目录" onclick=backToMenu()></p>

<p><a id=3.1>3.1 SQLite创建表</a><br></p>

<pre><code>基本语法结构: CREATE TABLE table_name(
                column1  datatype,
                ...
            );
</code></pre>

<p><a id=3.2>3.2 SQLite删除表</a><br/></p>

<pre><code>基本语法结构: DROP TABLE table_name;
</code></pre>

<p><font color=red size=3>**使用此命令需注意，一旦表删除，表中的信息也将永久删除**</font></p>

<p><a id=4.1>4.1 算数运算符</a><br/></p>

<table border="1" cellspacing="0">
<tr>
    <th style="width:20%">运算符
    </th>
    <th style="width:45%">描述
    </th>
    <th>实例
    </th>
</tr>
<tr>
    <td>+</td>
    <td>加法 - 把运算符两边的值相加</td>
    <td> a + b 将得到 30</td>
</tr>
<tr>
    <td>-</td><td>减法 - 左操作数减去右操作数</td>
    <td> a - b 将得到 -10</td>
</tr>
<tr>
    <td>*</td>
    <td>乘法 - 把运算符两边的值相乘</td>
    <td> a * b 将得到 200</td>
</tr>
<tr>
    <td>/</td>
    <td>除法 - 左操作数除以右操作数</td>
    <td> b / a 将得到 2</td>
</tr>
<tr>
    <td>%</td>
    <td>取模 - 左操作数除以右操作数后得到的余数</td>
    <td> b % a将得到 0</td>
</tr>
</table>


<p><a id=4.2>4.2 比较运算符</a><br/></p>

<table border=1 cellspacing=0>
<tbody>
<tr>
    <th style="width:20%">运算符</th>
    <th style="width:45%">描述</th>
    <th>实例</th>
</tr>
<tr>
    <td>==</td>
    <td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
    <td> (a == b) 不为真。</td>
</tr>
<tr>
    <td>=</td>
    <td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
    <td> (a = b) 不为真。</td>
</tr>
<tr>
    <td>!=</td>
    <td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
    <td> (a != b) 为真。</td>
</tr>
<tr>
    <td>&lt;&gt;</td>
    <td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
    <td> (a &lt;&gt; b) 为真。</td>
</tr>
<tr>
    <td>&gt;</td>
    <td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
    <td> (a &gt; b) 不为真。</td>
</tr>
<tr>
    <td>&lt;</td>
    <td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
    <td> (a &lt; b) 为真。</td>
</tr>
<tr>
    <td>&gt;=</td>
    <td>检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
    <td> (a &gt;= b) 不为真。</td>
</tr>
<tr>
    <td>&lt;=</td>
    <td>检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
    <td> (a &lt;= b) 为真。</td>
</tr>
<tr>
    <td>!&lt;</td>
    <td>检查左操作数的值是否不小于右操作数的值，如果是则条件为真。</td>
    <td> (a !&lt; b) 为假。</td>
</tr>
<tr>
    <td>!&gt;</td>
    <td>检查左操作数的值是否不大于右操作数的值，如果是则条件为真。</td>
    <td> (a !&gt; b) 为真。</td>
</tr>
</table>


<p><a id=4.3>4.3 逻辑运算符</a><br/></p>

<table border=1 cellspacing=0>
<tr>
    <th style="width:20%">运算符</th>
    <th style="width:80%">描述</th>
</tr>
<tr>
    <td>AND</td>
    <td>AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。</td>
</tr>
<tr>
    <td>BETWEEN</td>
    <td>BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</td>
</tr>
<tr>
    <td>EXISTS</td>
    <td>EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</td>
</tr>
<tr>
    <td>IN</td>
    <td>IN 运算符用于把某个值与一系列指定列表的值进行比较。</td>
</tr>
<tr>
    <td>NOT IN</td>
    <td>IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</td>
</tr>
<tr>
    <td>LIKE</td>
    <td>LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</td>
</tr>
<tr>
    <td>GLOB</td>
    <td>GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。</td>
</tr>
<tr>
    <td>NOT</td>
    <td>NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。<b>它是否定运算符。</b></td>
</tr>
<tr>
    <td>OR</td>
    <td>OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</td>
</tr>
<tr>
    <td>IS NULL</td>
    <td>NULL 运算符用于把某个值与 NULL 值进行比较。</td>
</tr>
<tr>
    <td>IS</td>
    <td>IS 运算符与 = 相似。</td>
</tr>
<tr>
    <td>IS NOT</td>
    <td>IS NOT 运算符与 != 相似。</td>
</tr>
<tr>
    <td>||</td>
    <td>连接两个不同的字符串，得到一个新的字符串。</td>
</tr>
<tr>
    <td>UNIQUE</td>
    <td>UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</td>
</tr>
</table>


<p><a id=4.4>4.4 位运算符</a><br/></p>

<table border=1 cellspacing=0>
<tr>
    <th width="20%">运算符</th>
    <th width="45%">描述</th>
    <th>实例</th>
</tr>
<tr>
    <td>&amp;</td>
    <td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
    <td> (A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
    <td>|</td>
    <td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
    <td> (A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
    <td>~</td>
    <td>二进制补码运算符是一元运算符，具有"翻转"位效应。</td>
    <td> (~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td>
</tr>
<tr>
    <td>&lt;&lt;</td>
    <td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
    <td> A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
    <td>&gt;&gt;</td>
    <td> 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
    <td> A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</table>


<p><a id=6.1>6.1 SQL Insert语句</a><br/></p>

<pre><code>基本语法:INSERT INTO TABLE_NAME (column1,...columnN) VALUES (value1,...valueN);
当要为表中所有列添加值，这时可以不用指定列名称,此时语法结构可以为:
INSERT INTO TABLE_NAME VALUES (value1, ...valueN);
</code></pre>

<p><a id=6.2>6.2 SQL Delete语句</a><br/></p>

<pre><code>基本语法结构:DELETE FROM table_name WHERE [condition];        
</code></pre>

<p><a id=6.3>6.3 SQL Update语句</a><br/></p>

<pre><code>基本语法结构:UPDATE table_name SET column1 = value1...., columnN = valueN 
WHERE [condition];
</code></pre>

<p><a id=6.4>6.4 SQL Select语句</a></p>

<pre><code>基本语法结构:SELECT column1, column2,... columnN FROM table_name;
如果要查询所有的数据，可以用 select * from table_name;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML基础标签总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/16/htmlji-chu-biao-qian-zong-jie/"/>
    <updated>2015-12-16T10:31:14+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/16/htmlji-chu-biao-qian-zong-jie</id>
    <content type="html"><![CDATA[<blockquote><p>离不开H5，就尽情的享受HTML带来的方便。学H5，从基本的HTML开始；</p></blockquote>

<h3>目录:</h3>

<p><a href=#1>1. HTML基本文档</a><br/>
<a href=#2>2. HTML基本标签</a><br/>
<a href=#3>3. HTML文本格式化</a><br/>
<a href=#4>4. 链接</a><br/>
<a href=#5>5. 样式/区块</a><br/>
<a href=#6>6. 表格</a><br/>
<a href=#7>7. 列表</a><br/>
<a href=#8>8. 框架</a><br/>
<a href=#9>9. 表单</a><br/>
<a href=#10>10. 实体</a><br/></p>

<!--more-->


<p><a id=1>1. HTML基本文档</a></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;文档标题&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
文本...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><a id=2>2. HTML基本标签</a><br/></p>

<pre><code>&lt;h1&gt;这是一级标题&lt;/h1&gt;
&lt;h2&gt;这是二级标题&lt;/h2&gt;
&lt;h3&gt;这是三级标题&lt;/h3&gt;
...
&lt;h6&gt;这是最小的标题&lt;/h6&gt;
&lt;p&gt;这是一个段落&lt;/p&gt;
&lt;br/&gt;  换行
&lt;hr/&gt;  水平线
&lt;!--这是注释--&gt;
</code></pre>

<p><a id=3>3. HTML文本格式化</a><br/></p>

<pre><code>&lt;b&gt;粗体文本&lt;/b&gt;
&lt;i&gt;斜体文本&lt;/i&gt;
&lt;strong&gt;加重语气－粗体显示&lt;/strong&gt;
&lt;em&gt;着重语气-斜体显示&lt;/em&gt;
&lt;small&gt;更小的文本&lt;/small&gt;
&lt;sub&gt;定义下标字&lt;/sub&gt;
&lt;sup&gt;定义上标字&lt;/sup&gt;
&lt;ins&gt;定义删除字&lt;/ins&gt;
&lt;del&gt;定义下划线&lt;del&gt;

&lt;code&gt;计算机代码&lt;/code&gt;
&lt;kbd&gt;键盘输入&lt;/kbd&gt;
&lt;samp&gt;计算机代码样本&lt;/samp&gt;
&lt;var&gt;定义变量&lt;/var&gt;
&lt;pre&gt;预格式文本&lt;/pre&gt;

&lt;abbr&gt;定义缩写&lt;/abbr&gt;
&lt;address&gt;定义地址&lt;/address&gt;
&lt;bdo&gt;定义文本的方向&lt;/bdo&gt;
&lt;q&gt;短引用&lt;/q&gt;
&lt;blockquote&gt;从另一个源引用的部分&lt;/blockquote&gt;
&lt;cite&gt;一般与blockquote连用，用来表示引用的源&lt;/cite&gt;
</code></pre>

<p><a id=4>4. 链接</a><br/></p>

<pre><code>普通的链接: &lt;a href="url"&gt;链接文本&lt;/a&gt;
图片: &lt;img src="url" alt="替换文本" height="高" width="宽"&gt;
图片链接: &lt;a href="url"&gt;&lt;img src="url" alt="替换文本"&gt;&lt;/a&gt;
邮件链接:    &lt;a href="mailto:mail_xxx@example.com"&gt;发送Email&lt;/a&gt;
书签: &lt;a id="tips"&gt;提示部分&lt;/a&gt;
    &lt;a href="#tips"&gt;跳转到提示部分&lt;/a&gt;
</code></pre>

<p><a id=5>5. 样式/区块</a><br/></p>

<pre><code>样式写法(一):
&lt;style type="text/css"&gt;
body {background-color:yellow;}
h1 {color:red;text-align:center;}
p  {color:green;}
&lt;/style&gt;    

样式写法(二):
&lt;body style="background-color:red;text-align:center;"&gt;...&lt;/body&gt;

样式写法(三):
&lt;link rel="当前文档与被链接文档之间的关系" type="text/css" href="url"&gt;

区块:主要功能是将页面模块分化，每一个模块有每一个模块的样式，方便进行处理
&lt;div&gt;块级元素&lt;/div&gt;

&lt;span&gt;内联元素&lt;/span&gt;
</code></pre>

<p><a id=6>6. 表格</a><br/></p>

<pre><code>&lt;table border="边宽"&gt;&lt;/table&gt;
&lt;caption&gt;表的标题&lt;/caption&gt;
&lt;tr&gt;定义一行&lt;/tr&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;td&gt;元素&lt;/td&gt;
colspan表示可跨越的列数
rowspan表示可跨越的行数
cellspacing 表示表格与表格边缘的距离

例子：
&lt;table border="1" style="text-align:center" cellspacing="0"&gt;
&lt;caption&gt;表格Demo&lt;/caption&gt;
&lt;tr&gt;
    &lt;th&gt;A&lt;/th&gt;
    &lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td colspan="2"&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<table border="1" style="text-align:center" cellspacing="0">
<caption>表格Demo</caption>
<tr>
    <th>A</th>
    <th>B</th>
</tr>
<tr>
    <td colspan="2">a</td>
</tr>
</table>


<p><a id=7>7. 列表</a><br/></p>

<pre><code>&lt;ol&gt;定义有序列表&lt;/ol&gt;
&lt;ul&gt;定义无序列表&lt;/ul&gt;
&lt;dl&gt;定义自定义列表&lt;/dl&gt;
&lt;dt&gt;自定义列表项目&lt;/dt&gt;
&lt;dd&gt;自定义列表的描述&lt;/dd&gt;
type 表示列表的类型

有序列表
&lt;ol type="1" start="50"&gt;
    &lt;li&gt;第一项&lt;/li&gt;
    &lt;li&gt;第二项&lt;/li&gt;
    &lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;

无序列表
&lt;ul&gt;
    &lt;li&gt;第一项&lt;/li&gt;
    &lt;li&gt;第二项&lt;/li&gt;
&lt;/ul&gt;

自定义列表 
&lt;dl&gt;
    &lt;dt&gt;项目名1&lt;/dt&gt;
        &lt;dd&gt;项目名描述1&lt;/dd&gt;
    &lt;dt&gt;项目名2&lt;/dt&gt;
        &lt;dd&gt;项目描述2&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>

<ol type="a" start="3">
        <li>第一项</li>
        <li>第二项</li>
        <li>第三项</li>
    </ol>


<p><a id=8>8. 框架</a><br/></p>

<pre><code>&lt;iframe src="url" width="宽" height="高" name="名称"&gt;定义框架&lt;/iframe&gt;
</code></pre>

<p><a id=9>9. 表单</a><br/></p>

<pre><code>&lt;form&gt;表单元素&lt;/form&gt;
&lt;input type="类型"&gt;输入&lt;/input&gt;
&lt;textarea&gt;文本框&lt;/textarea&gt;
&lt;label&gt;为 input 元素定义标注&lt;/label&gt;
&lt;fieldset&gt;在相关表单元素周围绘制边框/fieldset&gt;
&lt;legend&gt;为&lt;fieldset&gt;元素定义标题&lt;/legend&gt;
&lt;select&gt;下拉选项列表&lt;/select&gt;
&lt;optgroup&gt;定义选项组&lt;/optgroup&gt;
&lt;option&gt;&lt;select&gt;的选项&lt;/option&gt;
&lt;button&gt;定义一个按钮&lt;/button&gt;
&lt;datalist&gt;定义一个&lt;input&gt;元素可能选项列表&lt;/datalist&gt;
&lt;output&gt;定义一个计算结果&lt;/output&gt;

&lt;form&gt;
&lt;fieldset&gt;
&lt;legend&gt;表单DEMO&lt;/legend&gt;
输入框: &lt;input type="text" name="user"&gt;&lt;br/&gt;
密码框: &lt;input type="password" name="pwd"&gt;&lt;br/&gt;
单选框: &lt;input type="radio" name="singleChoose" value="1"&gt;&lt;br/&gt;
复选框: &lt;input type="checkbox" name="muilChoose" value="1"&gt;&lt;br/&gt;
提交按钮: &lt;input type="submit" value="提交"&gt;&lt;br/&gt;
下拉列表: &lt;select&gt;
    &lt;optgroup label="分类1"&gt;
            &lt;option value="1"&gt;1&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="分类2" disabled&gt;
            &lt;option value="2" selected&gt;2&lt;/option&gt;       &lt;/optgroup&gt;
    &lt;/select&gt;&lt;br/&gt;
文本框: &lt;textarea rows="2" cols="30"&gt;我是一个文本框&lt;/textarea&gt;
按钮: &lt;input type="button" value="按钮"&gt;或者&lt;button type="button"&gt;click&lt;/button&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>

<p><fieldset>
    <legend>表单DEMO</legend>
输入框: <input type="text" name="user"><br/>
密码框: <input type="password" name="pwd"><br/>
单选框: <input type="radio" name="singleChoose" value="1"><br/>
复选框: <input type="checkbox" name="muilChoose" value="1"><br/>
提交按钮: <input type="submit" value="提交"><br/>
下拉列表: <select>
        <optgroup label="分类1">
                <option value="1">1</option>
        </optgroup>
        <optgroup label="分类2" disabled>
                <option value="2" selected>2</option>       </optgroup>
        </select><br/>
文本框: <textarea rows="2" cols="30">我是一个文本框</textarea><br/>
按钮: <input type="button" value="按钮"><br/>
<button type="button">click</button>
</fieldset></p>

<p><a id=10>10. 实体</a><br/></p>

<pre><code>&lt; &amp;lt; &amp;#60;
&gt; $gt; &amp;#62;
© &amp;#169;
</code></pre>

<p><a href="http://www.runoob.com/html/html-tutorial.html" style="text-decoration:none;" target="_blank">Runoob教程链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(二)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er/"/>
    <updated>2015-12-14T18:11:05+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-er</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS可执行文件瘦身方法</font></div>


<blockquote><p>在第一部分中，我们已经介绍了如何获取可执行文件组成列表，以及如何查看静态链接库的占比的方法。这一部分我们将来仔细介绍可执行文件瘦身的具体方法；</p></blockquote>

<p><a href="http://blog.cnbang.net/tech/2544/">转载于bang&rsquo;s blog</a>
</br></p>

<!--more-->


<h3>编译选项</h3>

<ol>
<li>编译器优化级别
Build Settings->Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</li>
<li><p>去除符号信息
Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，详细信息见<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-97021-TPXREF121">官方文档</a>。</p>

<p>  这些选项目前都是XCode里release的默认选项，但旧版XCode生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/legacy/library/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.pdf">CodeFootprint.pdf</a></p></li>
</ol>


<h3>第三方库统计</h3>

<p>通过<a href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/">(一)</a>中对可执行文件的分析可以知道第三方库的占比，从而判断是否值得去找可执行方案去替换掉这个第三方库，转载作者写了一个node.js脚本，可以通过linkmap去统计每个.o目标文件占用的体积和每个.a静态库占用的体积.具体在<a href="https://gist.github.com/bang590/8f3e9704f1c2661836cd">详见这里</a></p>

<h3>ARC ->MRC</h3>

<p>具体没看懂，知道结论是可减少资源包的8%左右，有兴趣的可查看<a href="http://blog.cnbang.net/tech/2544/">原文</a>,但是这样程序的维护成本就上升了，如果没有特殊情况，一般不建议使用.</p>

<h3>无用代码</h3>

<p>在项目里新建一个类，给它添加几个方法，但不要在任何地方import它，build完项目后观察linkmap，你会发现这个类还是被编译进可执行文件了。
按C++的经验，没有被使用到的类和方法编译器都会优化掉，不会编进最终的可执行文件，但object-c不一样，因为object-c的动态特性，它可以通过类和方法名反射获得这个类和方法进行调用，所以就算在代码里某个类没被使用到，编译器也没法保证这个类不会在运行时通过反射去调用，所以只要是在项目里的文件，无论是否又被使用到都会被编译进可执行文件。
对此我们可以通过脚本，遍历整个项目的文件，找出所有没有被引用的类文件和没有被调用的方法，在保证没有其他地方动态调用的情况下把它们去掉。如果整个项目历时很长，历时代码遗留较多，这个清理对可执行文件省出的空间还是挺可观的。</p>

<h3>类/方法名的长度</h3>

<p>观察linkmap可以发现每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来。
对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩js一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它class-dump出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行hack。不过这样做有个缺点，就是crash堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆->原名的转换，实现和使用成本有点高。
实际上这部分占用的长度比较小，中型项目也就几百K，对安全性要求高的情况可以试试。</p>

<h3>冗余字符串</h3>

<p>代码上定义的所有静态字符串都会记录在在可执行文件的__cstring段，如果项目里Log非常多，这个空间占用也是可观的，也有几百K的大小，可以考虑清理所有冗余的字符串。另外如果有特别长的字符串，建议抽离保存成静态文件，因为AppStore对可执行文件加密导致压缩率低，特别长的字符串抽离成静态资源文件后压缩率会比在可执行文件里高很多。</p>

<h3>列一个清单</h3>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015121403.png" alt="效果展示" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App可执行文件瘦身(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-%5B%3F%5D/"/>
    <updated>2015-12-14T16:17:28+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/14/ios-appke-zhi-xing-wen-jian-shou-shen-[?]</id>
    <content type="html"><![CDATA[<div class="text" style="text-align:center;"><font size=6 color=red>iOS App可执行文件的组成</font></div>


<blockquote><p>面试的时候遇到的面试题，如何给App瘦身，之前有看过类似的题目，讲的大概就是两个方面，一、给资源文件瘦身，2、能下载处理的尽量通过后续下载来处理。但没有实际操作过。所以总感觉回答的不是那么个味道。回来问同事以及查资料后果然，需要两个方面来瘦身：1、减少资源包的大小；2、减少可执行文件的大小。1在本博客后续博客中会提到如何瘦身，本文主要讲解可执行文件瘦身的一部分，App可执行文件的组成；</p></blockquote>

<!--more-->


<p><a href="http://blog.cnbang.net/tech/2296/">转载于bang&rsquo;s blog </a></p>

<h3>查看App可执行文件组成的方法</h3>

<ol>
<li><p>XCode开启编译选项Write Link Map File
Xcode -> Project -> Build Setting ->搜索map ->设置Write Link Map File为Yes<br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121401.png" alt="展示图片" /></p></li>
<li><p>编译后，通过路径查找找到图中txt文件对应的文件
具体路径: ~/Library/Developer/Xcode/DerivedData/XXX-xxxxxxxxxxxx/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/XXX-LinkMap-xxx.txt<br/>
（这个LinkMap展示了整个App中可执行文件的全貌，列出了编译后的每一个.o文件，包括.a文件里的，以及每一个目标文件的代码段，数据段存储详情等）</p></li>
<li><p>以我目前手上的项目为例，在linkMap中的文件列表，有部分删减，为了方便讲解
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015121402.png" alt="展示图片" /></p>

<p>  第一部分(Object files部分)含义：<br/>
  前面中括号表示文件的编号，在后面的部分中会用到,后面表示可执行文件的位置</p>

<p>  第二部分(Sections部分)含义:<br/>
  Address表示偏移位置,Size表示大小,Segment表示段类型(<code>__TEXT</code>,保存程序代码段编译后的机器码，<code>__Data</code>),Section表示段名称(<code>__text</code>表示编译后的程序可执行语句，<code>__data</code>表示已初始化的全局变量和局部静态变量，<code>__bss</code>表示未初始化的全局变量和局部静态变量,<code>__csstring</code>表示代码里的字符串常量)</p>

<p>  可以发现每一行的数据都是紧跟在上一行数据后面， 即第二行到Address为第一行的Address加上第二行的Size组成</p>

<p>  第三部分(symbols部分)含义:
  Address 表示偏移位置,第二部分表示占用大小,第三部分表示所属文件序号，对应上述Object files列表，最后是文件名称</p></li>
<li><p>使用<br/>
 在了解了可执行文件的组成后，我们可以通过计算来获取某个静态库在项目中的占比，通过将.a静态库的.o加起来，就是这个静态库可执行部分占整个app空间的大小。（但是需要注意，此大小并不等于静态库的物理大小，此大小只是可执行文件的大小，要小于静态库的物理大小）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runloop的常见使用]]></title>
    <link href="http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong/"/>
    <updated>2015-12-09T16:32:18+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/09/runloopde-chang-jian-shi-yong</id>
    <content type="html"><![CDATA[<blockquote><p>在之前就做过倒计时的功能，最近封装了一个倒计时的控件，之前一直是用第三方库，没有仔细的去了解原理，最近刚好有时间，就研究了一下NSTimer这个类，在研究的过程中，就发现了，NSTimer需与NSRunLoop结合起来玩的才溜，于是就有了这一篇，在我之前项目中遇到的runloop使用以及结合相关资料的总结;这是第一部分，接下来会在另一篇博客中讲解runloop的原理，以及我对runloop的理解。</p></blockquote>

<!--more-->


<h3>用于“暂停”程序</h3>

<pre><code>- (void)start{
    NSLog(@"start new thread …");
    [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil];
    while (!end) {
        NSLog(@"runloop…");
    ① [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
        NSLog(@"runloop end.");
    }
    NSLog(@"ok.");

}

- (void)runOnNewThread{
    NSLog(@"run for new thread …");
    sleep(1);
    ② [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO];
    NSLog(@"end.");
}

- (void)setEnd{
    end=YES;
}
</code></pre>

<p>调用start方法，输出结果为</p>

<pre><code>2015-12-09 15:42:14.828 Test1[1648:451473] start new thread …
2015-12-09 15:42:14.829 Test1[1648:451473] runloop…
2015-12-09 15:42:14.829 Test1[1648:451585] run for new thread …
2015-12-09 15:42:15.829 Test1[1648:451585] end.
2015-12-09 15:43:00.010 Test1[1648:451473] runloop end.
2015-12-09 15:43:00.010 Test1[1648:451473] ok.
</code></pre>

<p>解释一下为什么要调用②，因为在调用此方法会向主线程发送消息，唤醒runloop，从而及时响应任务；</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码中不难看出，函数的调用顺序，runloop之前的部分 －> newThread部分 －> runloop之后的部分;这样就相当于帮我们形成了一个线程阻塞，但是while循环不受影响，<br/>
<font color=blue size=3>[常见应用场景:]</font>newThread处理网络请求，runloop前后控制是否显示进度菊花</p>

<p></br></p>

<h3>在使用NSTimer的同时使用NSRunloop</h3>

<p>①当使用<a href=#2015120901> scheduledTimerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120902> scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </a>创建NSTimer实例的时候，使用的mode为NSDefaultRunLoopMode</p>

<p>②当使用<a href=#2015120903> timerWithTimeInterval:invocation:repeats: </a> 和 <a href=#2015120904> timerWithTimeInterval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>③当使用<a href=#2015120906> initWithFireDate:interval:target:selector:userInfo:repeats: </a> 创建NSTimer实例的时候需要结合NSRunLoop类的 <a href=#2015120905> addTimer:forMode: </a> 方法将timer添加进runloop</p>

<p>在某些复杂页面，可能出现NSTimer计时延误的情况，有以下两条思路解决这个问题，1、在子线程中进行NSTimer的操作；2、仍然在主线程中进行NSTimer操作，但是将NSTimer加入到main runloop的特定的mode中；<br/>
</br>
方法1：</p>

<pre><code> if (self.timer) {
     [self.timer invalidate];
     self.timer = nil;
 }
 self.timer = [NSTimer timerWithTimeInterval:0.01 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
</code></pre>

<p>方法2:</p>

<pre><code>创建线程
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
 [thread start];

 //在子线程中做的事情 
-  (void)newThread
 {
     @autoreleasepool
    {
         [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] run];
     }
}
</code></pre>

<p>方法3:</p>

<pre><code>//声明全局变量
 dispatch_source_t _timers;


 uint64_t interval = 0.01 * NSEC_PER_SEC;
 dispatch_queue_t queue = dispatch_queue_create("my queue", 0);
 _timers = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
 dispatch_source_set_timer(_timers, dispatch_time(DISPATCH_TIME_NOW, 0), interval, 0);
  __weak ViewController *blockSelf = self;
 dispatch_source_set_event_handler(_timers, ^()
 {
     NSLog(@"Timer %@", [NSThread currentThread]);
     [blockSelf addTime];
 });
 dispatch_resume(_timers);

- (void)addTime{
    //然后在主线程中修改UI界面：
     dispatch_async(dispatch_get_main_queue(), ^{
             self.label.text = [NSString stringWithFormat:@"%.2f", self.timeCount/100];
     });
 }
</code></pre>

<p><b id=2015120901>+ scheduledTimerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                             invocation:(NSInvocation *)invocation
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120902>+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: </b></p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                                 target:(id)target
                               selector:(SEL)aSelector
                               userInfo:(id)userInfo
                                repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120903>+ timerWithTimeInterval:invocation:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120904>+ timerWithTimeInterval:target:selector:userInfo:repeats:</b></p>

<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                        target:(id)target
                      selector:(SEL)aSelector
                      userInfo:(id)userInfo
                       repeats:(BOOL)repeats
</code></pre>

<p><b id=2015120905>-  addTimer:forMode:</b></p>

<pre><code>- (void)addTimer:(NSTimer *)aTimer
     forMode:(NSString *)mode
</code></pre>

<p><b id=2015120906>- initWithFireDate:interval:target:selector:userInfo:repeats:</b></p>

<pre><code>- (instancetype)initWithFireDate:(NSDate *)date
                    interval:(NSTimeInterval)seconds
                      target:(id)target
                    selector:(SEL)aSelector
                    userInfo:(id)userInfo
                     repeats:(BOOL)repeats
</code></pre>

<p>  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">NSTimer官方参考文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的@dynamic]]></title>
    <link href="http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic/"/>
    <updated>2015-12-07T16:58:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/07/oczhong-de-at-dynamic</id>
    <content type="html"><![CDATA[<blockquote><p>在分析一份代码的时候，遇到了@dynamic，以前也遇到过，但是没有系统的总结一下，刚好有空，系统总结一下，为以后的使用做好准备；</p></blockquote>

<p>一、@dynamic与@synthesize的区别</p>

<ol>
<li>@property有两个对应的词，一个是@synthesize,另一个是@dynamic,当两个都没写的时候，系统会默认为写了@property的属性添加@synthesize var=_var;</li>
<li>@synthesize的语义为如果你没有重写getter或setter方法，系统会自动帮忙生成getter和setter方法，@dynamic的语义为getter和setter方法由用户自己实现，不自动生成；</li>
</ol>


<!--more-->


<p>二、@dynamic的读取<br/>
View.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface View : UIView
{
    NSString * _name;
}

@property (nonatomic,copy) NSString *name;

@end
</code></pre>

<p>View.m</p>

<pre><code>#import "View.h"

@implementation View

@dynamic name;

- (void)setName:(NSString *)name{
   _name = name;
}

- (NSString*)name{
   return _name;
}

@end
</code></pre>

<p>如果没有写setter和getter两个方法，调用的时候，[[View alloc] init].name会报错，但是将@dynamic换成@synthesize的话没有getter和setter也不会有问题；</p>

<p>三、@dynamic的使用</p>

<ol>
<li>用于NSManagedObject中，告诉编译器不要处理属性的getter和setter方法，由CoreData框架来生成getter和setter方法</li>
<li><p>用于分类中,具体使用需要结合到runtime，让分类可以存在属性变量<br/>
例子如下：<br/>
NSObject + AAA.h</p>

<pre><code>  #import &lt;Foundation/Foundation.h&gt;

  @interface NSObject (AAA)
  @property (nonatomic,copy) NSString *aaa;

  @end
</code></pre></li>
</ol>


<p>NSObjct + AAA.m</p>

<pre><code>    #import "NSObject+AAA.h"
    #import &lt;objc/runtime.h&gt;

    static const void *kAAAIdentifier = (void*)@"kAAAIdentifier";

    @implementation NSObject (AAA)

    @dynamic aaa;

    - (void)setAaa:(NSString *)aaa{
            objc_setAssociatedObject(self, kAAAIdentifier, aaa, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }

    - (NSString*)aaa{
        return  objc_getAssociatedObject(self, kAAAIdentifier);
    }

    @end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress部分设置总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie/"/>
    <updated>2015-12-03T17:12:12+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/octopressbu-fen-she-zhi-zong-jie</id>
    <content type="html"><![CDATA[<blockquote><p>此文主要用来总结在设置Octopress时遇到的一些需求，但不好找的部分</p></blockquote>

<!--more-->


<p></br></p>

<h3>在首页只显示部分文章内容</h3>

<p><strong>修改原因:</strong>默认情况下，首页会显示每一篇文章的全部，这样给用户的感觉不是很好，首页应该只显示一个对文章的简单介绍，这样既方便了用户查看总体的文件介绍，找到感兴趣的，又不会给用户首页和文章详情是一样的感觉，引导用户点击进入查看全文</p>

<p><strong>设置原理:</strong>在_config.yml里面设置了分隔符<font color=red size=3>excerpt_sepatator</font></p>

<p><strong>设置方法:</strong>将_config.yml里面的<font color=red size=3>excerpt_link</font>字段对应的值中<em>”Continue reading“</em>部分引导用户点击查看全文的文字,并在相应的文章对应的Markdown文档中,找到恰当的地方，加入代码<code>&lt;!--more--&gt;</code></p>

<p><strong>设置以及效果展示</strong>  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120302.png" alt="展示1" />
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120301.png" alt="展示2" /></p>

<p></br></p>

<h3>设置字体、背景色</h3>

<p><strong>修改原因:</strong>可能在撰写markdown文章的时候需要用到文本强调，但markdown常用的语法中并没有提供语法用于改变字体以及背景色</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong></p>

<ol>
<li><font color=red size=2>设置字体</font> 在需要改变属性的文本加上标签<code>&lt;font color=字体颜色 size=字体大小&gt;文本&lt;/font&gt;</code></li>
<li><font color=red size=2>设置背景色</font> 在需要改变背景的文本加上标签<code>&lt;td bgcolor=背景颜色&gt;文本&lt;/td&gt;</code></li>
</ol>


<p><strong>设置Demo</strong></p>

<pre><code>&lt;font color=red size=5&gt;Markdown&lt;/font&gt;
</code></pre>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=red size=5>Markdown</font></p>

<pre><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#ff4500&gt;Markdown&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
或&lt;span style=background-color:#ff4500&gt;Markdown&lt;/span&gt; 
</code></pre>

<table><tr><td bgcolor=#ff4500><font color=white size=2>Markdown</font></td></tr></table>


<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=background-color:#ff4500><font color=white size=2>Markdown</font></span></p>

<p></br></p>

<h3>设置空格</h3>

<p><strong>修改原因:</strong>默认的情况下markdown语法会顶格写，这样不符合一些写作习惯，且在markdown文档中无论敲多少空格，默认只显示一个文本间距，对其实现成难题</p>

<p><strong>设置原理:</strong>markdown的兼容HMTML，可以用部分HTML来实现我们想要的效果</p>

<p><strong>设置方法：</strong> 通过<code>&amp;nbsp;</code>来实现字符空格(注意每一个&amp;nbsp相当于一个字符,但中文为两个字符)</p>

<p><strong>设置效果</strong><br/>
<font color=red size=4>Mark&nbsp;&nbsp;Down</font><br/>
<font color=red size=4>你&nbsp;&nbsp;&nbsp;&nbsp;好</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIBezierPath学习总结]]></title>
    <link href="http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie/"/>
    <updated>2015-12-03T17:00:10+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/03/uibezierpathxue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p><link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css"></p>

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>


<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>




<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>


<div id="category"></div>


<blockquote><p>UIBezierPath对象是CGPathRef数据类型的封装，每一个连接的直线或者去险段的集合称为subpath，一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths，使用UIBezierPath类可以创建机遇矢量的路径，使用此类可以定义简单的形状，如椭圆或者矩形，也可以定义稍微复杂的形状，如多个直线和曲线组成的形状;</p></blockquote>

<!--more-->


<h3>1.UIBezierPath的创建</h3>

<h4>1.1. + bezierPath</h4>

<pre><code>+ (instancetype)bezierPath
返回一个UIBezierPath实例;
</code></pre>

<h4>1.2. + bezierPathWithRect:</h4>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect
传入一个CGRect，构建一个矩形
</code></pre>

<h4>1.3. + bezierPathWithOvalInRect:</h4>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect
传入一个CGRect，构建一个内切椭圆
</code></pre>

<h4>1.4. + bezierPathWithRoundedRect:cornerRadius:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                         cornerRadius:(CGFloat)cornerRadius
创建一个圆角矩形，其中rect为矩形的rect，cornerRadius为圆角率
</code></pre>

<h4>1.5. + bezierPathWithRoundedRect:byRoundingCorners:cornerRadii:</h4>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                    byRoundingCorners:(UIRectCorner)corners
                          cornerRadii:(CGSize)cornerRadii
构建一个可指定圆角的矩形,其中rect为矩形的rect，corners为需要圆角的角,cornerRadii为圆角
率(sized的    组成最大不能超过宽高的一半)
</code></pre>

<h4>1.6. + bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center
                             radius:(CGFloat)radius
                         startAngle:(CGFloat)startAngle
                           endAngle:(CGFloat)endAngle
                          clockwise:(BOOL)clockwise
创建一段圆弧,center为圆弧的圆心，radius为半径,startAngle为开始弧度，endAngle为结束弧
度,clockwise为方向  (默认YES为顺时针方向，No为逆时针方向)，具体的开始点与结束点看下方参
考图  
</code></pre>

<p>其中正右顶点为起始点也为结束点,顺时针依次增加;  <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120401.png" alt="参考图" /><br/>
<font color=red size=3>[注意]:</font>之所以强调顺时针方向与逆时针防线的原因是，当起始弧度与结束弧度相同的时候，不同的方向画线会得到不同的结果，如0和π/2，顺时针会得到右下部的1/4部分，但逆时针会得到上面的3/4部分;</p>

<h4>1.7. + bezierPathWithCGPath:</h4>

<pre><code>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath
用CGPath创建一个UIBezierPath
</code></pre>

<h4>1.8. - bezierPathByReversingPath</h4>

<pre><code>- (UIBezierPath *)bezierPathByReversingPath
创建一个与原bezierPath路径相同，方向相反的bezierPath对象
</code></pre>

<h3>2. 构建路径</h3>

<h4>2.1. - moveToPoint:</h4>

<pre><code>- (void)moveToPoint:(CGPoint)point
移动起始点到指定位置
</code></pre>

<h4>2.2. - addLineToPoint:</h4>

<pre><code>- (void)addLineToPoint:(CGPoint)point
从起始点增加一条线到指定的point，并在下一次改变时把point当起始点
</code></pre>

<h4>2.3. - addArcWithCenter:radius:startAngle:endAngle:clockwise:</h4>

<pre><code>- (void)addArcWithCenter:(CGPoint)center
              radius:(CGFloat)radius
          startAngle:(CGFloat)startAngle
            endAngle:(CGFloat)endAngle
           clockwise:(BOOL)clockwise
增加一段圆弧，center为圆弧的圆心,radius为圆弧的半径,startAngle为起始圆弧度数,endAngle
为终止圆弧度数,clockwise为是否是顺时钟，与
（+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:）
的演示图中度数的起始点和终止点相同
</code></pre>

<h4>2.4. - addQuadCurveToPoint:controlPoint:</h4>

<pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint
           controlPoint:(CGPoint)controlPoint
新增一段二阶贝塞尔曲线，其中endPoint为结束点，controlPoint为控制点
</code></pre>

<p>二阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120402.png" alt="演示图2" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.5. - addCurveToPoint:controlPoint1:controlPoint2:</h4>

<pre><code>- (void)addCurveToPoint:(CGPoint)endPoint
      controlPoint1:(CGPoint)controlPoint1
      controlPoint2:(CGPoint)controlPoint2
新增一段三阶贝塞尔曲线，其中endPoint结束点，controlPoint1为控制点1,controlPoint2为控制点2
</code></pre>

<p> 三阶贝塞尔曲线的示意图：
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120403.png" alt="演示图3" /></p>

<p><font color=red size=3>[注意]:</font>  此函数在调用前必须要先调用-moveToPoint:函数</p>

<h4>2.6. - closePath</h4>

<pre><code>- (void)closePath
用线段连接最后一个点与最初起始点，使成为一个封闭的形状
</code></pre>

<h4>2.7. - removeAllPoints</h4>

<pre><code>- (void)removeAllPoints
移除所有的点，同时也移除所有的线
</code></pre>

<h4>2.8. - appendPath:</h4>

<pre><code>- (void)appendPath:(UIBezierPath *)bezierPath
将一段路径连接到另外一段路径后面
</code></pre>

<h4>2.9. CGPath <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGPathRef CGPath
主要作用就是获取UIBezierPath的CGPathRef实例，可以用于初始化或者添加到另一个path中。
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
+ bezierPathWithCGPath:  <br/>
- appendPath:</p>

<h4>2.10. cuttrentPoint  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic, readonly) CGPoint currentPoint
主要用于获取当前的坐标点，如果当前路径为空，则当前点的值为坐标原点
</code></pre>

<h3>3. 绘图属性</h3>

<h4>3.1. lineWidth  <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGFloat lineWidth
绘图线的宽度,默认为1.0
</code></pre>

<h4>3.2. lineCapStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineCap lineCapStyle
设置起点和终点的样式

enum CGLineCap{
    kCGLineCapButt,
    kCGLineCapRound,
    kCGLineCapSquare 
};
typedef enum CGLineCap CGLineCap;
</code></pre>

<h4>3.3. lineJoinStyle <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property(nonatomic) CGLineJoin  lineJoinStyle
设置线段连接点的样式

enum CGLineJoin{
    kCGLineJoinMiter,  
    kCGLineJoinRound,
    kCGLineJoinBevel 
}; 
typedef enum CGLineJoin CGLineCap;
</code></pre>

<h4>3.4. usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></h4>

<pre><code>@property (nonatomic) BOOL usesEvenOddFillRule
判断是否使用奇-偶规则绘图, 默认为NO,即采用非零环绕规则绘图
</code></pre>

<p><font color=orange>［名词解释］:</font> 奇－偶规则: 从任意位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。<br/>
非零环绕规则: 首先使多边形的边变为矢量。将环绕数初始化为零。再从任意位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。左边为奇－偶规则的渲染图，右边为非零环绕规则的渲染图；
<img src="http://7xopon.com1.z0.glb.clouddn.com/2015120404.png" alt="演示图4" /></p>

<h4>3.5. - setLineDash:count:phase:</h4>

<pre><code>- (void)setLineDash:(const CGFloat *)pattern
          count:(NSInteger)count
          phase:(CGFloat)phase
画一条虚线,其中pattern为一个C风格的数组，包含段点的长度，count为pattern的数量，phase为
间隔的宽度

例子:    
UIBezierPath *path = [UIBezierPath bezierPath];

path.lineWidth = 5;
path.lineJoinStyle = kCGLineJoinRound;
path.lineCapStyle = kCGLineCapRound;
[path moveToPoint:CGPointMake(100, 100)];
[path addLineToPoint:CGPointMake(200, 100)];

CGFloat a[] = {10};
[path setLineDash:a count:1 phase:5];
</code></pre>

<p><img src="http://7xopon.com1.z0.glb.clouddn.com/2015120406.png" alt="演示图5" /></p>

<h4>3.6 - getLineDash:count:phase:</h4>

<pre><code>- (void)getLineDash:(CGFloat *)pattern
          count:(NSInteger *)count
          phase:(CGFloat *)phase
获取虚线中的属性，pattern为C风格的数组，包含段点的信息,count包含pattern的数量，phase为
间隔的宽度，必须要确保pattern数组足够大，当不知道pattern的长度的时候，可以调用两次该方法，
第一次pattern传NULL，然后根据返回的count值创建数组，再次调用；
</code></pre>

<h4>3.7. - containsPoint:</h4>

<pre><code>- (BOOL)containsPoint:(CGPoint)point
判断点是否在某个封闭区域内，必须是封闭区域，可以调用－ closePath；
</code></pre>

<p><font color=blue>［相关的函数］:</font> <br/>
- closePath:  <br/>
usesEvenOldFillRule <font color=gray size=2><em>Property</em></font></p>

<h3>4. 绘图</h3>

<h4>4.1. - fillWithBlendMode:alpha:</h4>

<pre><code>- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha
填充一个path，blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.2. - strokeWithBlendMode:alpha:</h4>

<pre><code>- (void)strokeWithBlendMode:(CGBlendMode)blendMode
                  alpha:(CGFloat)alpha
以某种方式渲染边界线,blendMode，渲染模式；alpha，透明度
</code></pre>

<h4>4.3. -fill</h4>

<pre><code>- (void)fill
填充某个路径
</code></pre>

<h4>4.4 - stroke</h4>

<pre><code>- (void)stroke
绘制路径
</code></pre>

<h3>5.动画</h3>

<h4>5.1 - applyTransform:</h4>

<pre><code>- (void)applyTransform:(CGAffineTransform)transform
对路径实现变换，transform变换
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS链式开发(一)]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-%5B%3F%5D/"/>
    <updated>2015-12-02T16:29:31+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioslian-shi-kai-fa-[?]</id>
    <content type="html"><![CDATA[<blockquote><p>烦不烦？当你需要调用一组动画的时候，需要一个个函数组件的去调用，其实你可以运用你之前学过的block，来实现如一系列的连贯触发行为；</p></blockquote>

<h3>什么是链式开发</h3>

<p>简单的说就是通过“.”操作符调用一系列的操作；</p>

<!--more-->


<h3>链式开发在OC中操作的原理</h3>

<p>原理：结合类属性的getter属性可以通过.调用的特性，我们可以在每一个需要触发的链式环节，定义一个类属性，然后再类属性中返回类的实例，这样，就可以一系列的执行下去；</p>

<p>如:假设有类ChainInvoking;以及属性<code>@property （nonatomic, copy）ChainInvoking* invoking;</code>
则</p>

<pre><code>－ （ChainInvoking* ）invoking{
    /**
        我们想做的事情;
    **/
    return self;
}
</code></pre>

<p>那么此时，self.invoking与self在意义上其实是相等的，不过在self.invoking已经帮我们做了我们想做的事情，一次类推，如果我们有一系列的动作，那么<code>self.invoking1.invoking2...</code>也是可行的，这样就实现了我们的链式调用</p>

<h3>为什么用block而不是直接用类属性</h3>

<ol>
<li>类属性不能传入参数，那么相应的一些功能的时候局限性更大</li>
<li>在最后一个调用的时候，会报警告"Property access result unused-getter should not be used for side effects",意思大概就是获取的getter值，没有实际用途;<br/>
<strong>综上</strong>,最好的办法是使用block 类属性，下面会给大家展示一个例子;</li>
</ol>


<h3>链式操作的实现</h3>

<p>用一个例子说明： <br/>
<strong>ChainedInvoking.h</strong></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface ChainedInvoking : NSObject

@property (nonatomic, copy) ChainedInvoking* (^eat1)();
@property (nonatomic, copy) ChainedInvoking* (^eat)(NSString* );
@property (nonatomic, copy) ChainedInvoking* (^run)();
@property (nonatomic, copy) ChainedInvoking* (^learn)();

@property (nonatomic, copy) ChainedInvoking* play;
@property (nonatomic, copy) ChainedInvoking* sing;
@end
</code></pre>

<p><strong>ChainedInvoking.m</strong></p>

<pre><code>#import "ChainedInvoking.h"

@implementation ChainedInvoking

- (ChainedInvoking* (^)())eat1{  
   return ^{
        NSLog(@"吃饭");
        return self;
  };
}

- (ChainedInvoking* (^)())learn{
    return ^{
     NSLog(@"学习");
        return self;
    };
}   

- (ChainedInvoking* (^)())run{
    return ^{
        NSLog(@"跑步");
        return self;
    };
}

- (ChainedInvoking* (^)(NSString* food))eat{
    return ^(NSString* food){
        NSLog(@"吃---%@",food);
        return self;
    };
}

- (ChainedInvoking*)play{
    NSLog(@"玩耍!");
    return self;
}

- (ChainedInvoking*)sing{
    NSLog(@"唱歌!");
    return self;
}       

@end
</code></pre>

<p><strong>调用:   </strong></p>

<pre><code>ChainedInvoking* invoking = [[ChainedInvoking alloc] init];
invoking.eat1().run().learn().eat(@"辣子鸡饭"); ①
invoking.play.sing.eat(@"红烧牛肉面"); ②
</code></pre>

<p><strong>结果</strong><br/>
①</p>

<pre><code>吃饭
跑步
学习
吃-－－辣子鸡饭
</code></pre>

<p>②</p>

<pre><code>玩耍
唱歌
吃红烧牛肉面
</code></pre>

<h3>参考文档</h3>

<p><a href="http://www.cocoachina.com/ios/20151123/14317.html">使用OC链式调用方式简化SpriteKit的动画调用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用跳转设置]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi/"/>
    <updated>2015-12-02T14:50:56+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/ioschang-yong-tiao-zhuan-she-zhi</id>
    <content type="html"><![CDATA[<blockquote><p>经常会在应用中应用中遇到这样的问题，在app内部运行到某个场景的时候，需要打开系统的某项设置，但由于用户的不小心操作，或者当时的一些小想法而在系统弹框的时候选择了拒绝，之后就不能收到某项服务或者在app运行的环节中造成断片，这个时候我们就需要提醒用户手动去去打开系统设置，然后打开相应的服务，这给用户的体验是不好的，最好的用户体验是，如果用户拒绝了某项服务，但当他进入这个应用场景的时候，弹框提示用户的同时，还应该跳转到响应的系统设置页面，进行设置。</p></blockquote>

<!--more-->


<p></br></p>

<h3>跳转本App设置界面以及相应的系统版本</h3>

<p>需要请求一下位置权限或者通知权限，才可以跳进自己的app设置里面，如果没有任何权限请求，就只能跳到系统的设置界面<br/>
<strong>iOS8及以上</strong></p>

<pre><code>        NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
        if([[UIApplication sharedApplication] canOpenURL:url]) {
            NSURL*url =[NSURL URLWithString:UIApplicationOpenSettingsURLString];
            [[UIApplication sharedApplication] openURL:url];
        }
</code></pre>

<p><strong>iOS8以下</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开应用的相册、推送、位置等等信息的时候会跳转到相应的页面</p>

<p></br></p>

<h3>跳转到系统设置</h3>

<p><strong>通用模版</strong></p>

<ol>
<li><p>设置Url Schemes(Target > info > URL Type)<br/>
     <img src="http://7xopon.com1.z0.glb.clouddn.com/8.png" alt="urlSchemes设置" /></p></li>
<li><p>项目相应位置相应的代码<br/>
＃define kCommonMacro  系统设置root</p>

<pre><code>   NSURL *url = [NSURL URLWithString:@"kCommonMacro"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }

  例子:
  **WIFI**
   NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
  if ([[UIApplication sharedApplication] canOpenURL:url]) {
      [[UIApplication sharedApplication] openURL:url];
   }
</code></pre></li>
</ol>


<p><strong>常用的系统设置prefs</strong></p>

<ul>
<li><p>Notification <pre/>prefs:root=NOTIFICATIONS_ID</p></li>
<li><p>About <pre/>prefs:root=General&amp;path=About</p></li>
<li><p>Accessibility <pre/>prefs:root=General&amp;path=ACCESSIBILITY</p></li>
<li><p>AirplaneModeOn <pre/>prefs:root=AIRPLANE_MODE</p></li>
<li><p>Auto-Lock <pre/>prefs:root=General&amp;path=AUTOLOCK</p></li>
<li><p>Brightness <pre/>prefs:root=Brightness</p></li>
<li><p>Bluetooth <pre/>prefs:root=General&amp;path=Bluetooth</p></li>
<li><p>Date&amp; Time <pre/>prefs:root=General&amp;path=DATE_AND_TIME</p></li>
<li><p>FaceTime <pre/>prefs:root=FACETIME</p></li>
<li><p>General <pre/>prefs:root=General</p></li>
<li><p>Keyboard <pre/>prefs:root=General&amp;path=Keyboard</p></li>
<li><p>iCloud <pre/>prefs:root=CASTLE  iCloud</p></li>
<li><p>Storage &amp; Backup <pre/>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</p></li>
<li><p>International <pre/>prefs:root=General&amp;path=INTERNATIONAL</p></li>
<li><p>Location Services <pre/>prefs:root=LOCATION_SERVICES</p></li>
<li><p>Music <pre/>prefs:root=MUSIC</p></li>
<li><p>Music Equalizer <pre/>prefs:root=MUSIC&amp;path=EQ</p></li>
<li><p>Music VolumeLimit <pre/>prefs:root=MUSIC&amp;path=VolumeLimit</p></li>
<li><p>Network <pre/>prefs:root=General&amp;path=Network</p></li>
<li><p>Nike + iPod <pre/>prefs:root=NIKE_PLUS_IPOD</p></li>
<li><p>Notes <pre/>prefs:root=NOTES</p></li>
<li><p>Phone <pre/>prefs:root=Phone</p></li>
<li><p>Photos <pre/>prefs:root=Photos</p></li>
<li><p>Profile <pre/>prefs:root=General&amp;path=ManagedConfigurationList</p></li>
<li><p>Reset <pre/>prefs:root=General&amp;path=Reset</p></li>
<li><p>Safari <pre/>prefs:root=Safari</p></li>
<li><p>Siri <pre/>prefs:root=General&amp;path=Assistant</p></li>
<li><p>Sounds <pre/>prefs:root=Sounds</p></li>
<li><p>SoftwareUpdate <pre/>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</p></li>
<li><p>Store <pre/>prefs:root=STORE</p></li>
<li><p>Twitter <pre/>prefs:root=TWITTER</p></li>
<li><p>Usage <pre/>prefs:root=General&amp;path=USAGE</p></li>
<li><p>VPN <pre/>prefs:root=General&amp;path=Network/VPN</p></li>
<li><p>Wallpaper <pre/>prefs:root=Wallpaper</p></li>
<li><p>Wi-Fi <pre/>prefs:root=WIFI</p></li>
<li><p>Setting  <pre/>prefs:root=INTERNET_TETHERING</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法学习]]></title>
    <link href="http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi/"/>
    <updated>2015-12-02T14:05:11+08:00</updated>
    <id>http://macro44.github.io/blog/2015/12/02/markdownyu-fa-xue-xi</id>
    <content type="html"><![CDATA[<blockquote><p>基于一些巧合的原因接触了Octopress制作个人博客，在基本上搞定了所有基础框架的基础上，开始创建第一篇博客，但是发现，主体文章是基于Markdown的文档，之前基本上没有任何了解，搜集各种资料以及各个大神的博客，初步了解了一些基础语法，总结如下，希望能给以后的自己或你们提供力所能及的帮助;</p></blockquote>

<!--more-->


<h3>学习工具</h3>

<p>推荐使用Mou,<a href="http://25.io/mou/">下载地址</a></p>

<h3>学习历程:</h3>

<ul>
<li>了解最基本的语法</li>
<li>尝试把所有的语法运用到一个简单的Demo中</li>
</ul>


<h3>基本语法</h3>

<p>大致分为4个部分：文本、列表、样式、图片链接</p>

<h4>文本</h4>

<ul>
<li>文字粗体 语法为: <strong>变粗的文本</strong></li>
<li>文本斜体 语法为: <em>斜体部分</em></li>
<li>下标     语法为: someText[^flag] [^flag]:des<br/>
<strong>需要特别注意</strong> 下标语法中标记与解释不能放在一行中完成     <br/>
<img src="http://7xopon.com1.z0.glb.clouddn.com/3.png" alt="图片效果" /></li>
</ul>


<h4>列表</h4>

<ul>
<li>有序列表  语法: 阿拉伯数字+.  如1.</li>
<li>无序列表  语法: -或*+需要序列化的字符串,如基本语法样式</li>
<li>列表＋代码  语法: 首先换行，删掉头部的自动添加的列表符号，然后连续两个Tab或者8个空格 <br/>
<strong>需要特别注意</strong> 无论是有序还是无序，系统只会保持一种风格，且符号与文本之间必须隔着一个空格
 <img src="http://7xopon.com1.z0.glb.clouddn.com/5.png" alt="图片效果" /></li>
</ul>


<h4>样式</h4>

<ul>
<li>一级标题 语法为: #Markdown</li>
<li>二级标题 语法为: ##Markdown</li>
<li>三级标题 语法为: ###Markdown</li>
<li>引导语   语法为:> + 空格 +文本 如> 你好</li>
<li>段落分隔线 语法为: &mdash; 或者  ***</li>
<li>简单文字代码框   语法为: <code>代码段</code></li>
<li>段落代码框      语法为:Tab/4个空格+代码段（需要注意Tab前面不能存在含有意义的*,如果存在可用分割线来分隔)</li>
<li><p>表格     语法为:</p>

<pre><code>| 列名        | 列名          | 列名  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre>

<p><strong>需要特别注意</strong>本区块的代码必须要独立一行书写，且引导语标志必须➕空格
<img src="http://7xopon.com1.z0.glb.clouddn.com/6.png" alt="图片效果" /></p></li>
</ul>


<h4>图片与链接</h4>

<ul>
<li>   链接    语法为: <a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名</a> 如<a href="www.baidu.com">百度</a></li>
<li>   图片    语法为<img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="图片名" />
如<img src="http://7xopon.com1.z0.glb.clouddn.com/1.jpg" alt="Mou icon" /></li>
</ul>


<h3>Demo范文</h3>

<p>本文Markdown源码：有兴趣的可以试着敲一遍!
<img src="http://7xopon.com1.z0.glb.clouddn.com/7.png" alt="Demo范文" /></p>
]]></content>
  </entry>
  
</feed>
